
.
|-- README.md
|-- bun.lockb
|-- components.json
|-- eslint.config.js
|-- gerar_resumo_V_360.sh
|-- index.html
|-- package-lock.json
|-- package.json
|-- postcss.config.js
|-- public
|   |-- favicon.ico
|   |-- placeholder.svg
|   `-- robots.txt
|-- resumo_automatico_projeto.txt
|-- src
|   |-- App.css
|   |-- App.tsx
|   |-- components
|   |   |-- AppHeader.tsx
|   |   |-- AppSidebar.tsx
|   |   |-- JsonViewDialog.tsx
|   |   |-- NotificationDialog.tsx
|   |   |-- ProtectedRoute.tsx
|   |   `-- ui
|   |       |-- accordion.tsx
|   |       |-- alert-dialog.tsx
|   |       |-- alert.tsx
|   |       |-- aspect-ratio.tsx
|   |       |-- avatar.tsx
|   |       |-- badge.tsx
|   |       |-- breadcrumb.tsx
|   |       |-- button.tsx
|   |       |-- calendar.tsx
|   |       |-- card.tsx
|   |       |-- carousel.tsx
|   |       |-- chart.tsx
|   |       |-- checkbox.tsx
|   |       |-- collapsible.tsx
|   |       |-- command.tsx
|   |       |-- context-menu.tsx
|   |       |-- dialog.tsx
|   |       |-- drawer.tsx
|   |       |-- dropdown-menu.tsx
|   |       |-- form.tsx
|   |       |-- hover-card.tsx
|   |       |-- input-otp.tsx
|   |       |-- input.tsx
|   |       |-- label.tsx
|   |       |-- menubar.tsx
|   |       |-- navigation-menu.tsx
|   |       |-- pagination.tsx
|   |       |-- popover.tsx
|   |       |-- progress.tsx
|   |       |-- radio-group.tsx
|   |       |-- resizable.tsx
|   |       |-- scroll-area.tsx
|   |       |-- select.tsx
|   |       |-- separator.tsx
|   |       |-- sheet.tsx
|   |       |-- sidebar.tsx
|   |       |-- skeleton.tsx
|   |       |-- slider.tsx
|   |       |-- sonner.tsx
|   |       |-- switch.tsx
|   |       |-- table.tsx
|   |       |-- tabs.tsx
|   |       |-- textarea.tsx
|   |       |-- toast.tsx
|   |       |-- toaster.tsx
|   |       |-- toggle-group.tsx
|   |       |-- toggle.tsx
|   |       |-- tooltip.tsx
|   |       `-- use-toast.ts
|   |-- contexts
|   |   `-- AuthContext.tsx
|   |-- hooks
|   |   |-- use-mobile.tsx
|   |   `-- use-toast.ts
|   |-- index.css
|   |-- integrations
|   |   `-- supabase
|   |       |-- client.ts
|   |       `-- types.ts
|   |-- lib
|   |   `-- utils.ts
|   |-- main.tsx
|   |-- pages
|   |   |-- Auth.tsx
|   |   |-- Configuracoes.tsx
|   |   |-- Dashboard.tsx
|   |   |-- Index.tsx
|   |   |-- NotFound.tsx
|   |   |-- Planos.tsx
|   |   |-- Revenda.tsx
|   |   |-- Templates.tsx
|   |   |-- Webhooks.tsx
|   |   `-- WhatsAppConnection.tsx
|   `-- vite-env.d.ts
|-- supabase
|   |-- config.toml
|   |-- functions
|   |   |-- create-reseller-user
|   |   |   `-- index.ts
|   |   |-- delete-reseller-user
|   |   |   `-- index.ts
|   |   |-- evolution-webhook-receiver
|   |   |   `-- index.ts
|   |   |-- log-n8n-qr-interaction
|   |   |   `-- index.ts
|   |   `-- update-reseller-user
|   |       `-- index.ts
|   `-- migrations
|       |-- 20251024172442_67b980cf-a2ee-4a91-8981-9f1c055189aa.sql
|       |-- 20251024172806_d771aa55-9c11-4d74-b66b-2a43f03709a0.sql
|       |-- 20251027192502_171389d1-586b-44ed-8a4e-088532457ea7.sql
|       |-- 20251027192813_6f66c686-3cb3-4173-a0ad-d6368fec3f9b.sql
|       |-- 20251027193838_5c5d133f-a1a0-48a1-a8d8-661e770be033.sql
|       |-- 20251027202338_10d08ea8-950b-461d-bea3-a44b29e2b74b.sql
|       |-- 20251027203423_67d3aa70-7d6e-4556-af72-409014b08ff9.sql
|       |-- 20251027204334_ffa8362d-cda5-4ec2-8b0e-0695769076ae.sql
|       |-- 20251027211430_c14cfc0f-45a5-4881-826c-c6a9ae93a9cc.sql
|       |-- 20251027222923_af059369-6b22-4dff-abc5-0fdf4ee1bb1b.sql
|       `-- 20251027224604_59a7a3a1-bf8c-4be3-82e4-23b0a9ed3f42.sql
|-- tailwind.config.ts
|-- tsconfig.app.json
|-- tsconfig.json
|-- tsconfig.node.json
`-- vite.config.ts

18 directories, 110 files

{
  "@hookform/resolvers": "^3.10.0",
  "@radix-ui/react-accordion": "^1.2.11",
  "@radix-ui/react-alert-dialog": "^1.1.14",
  "@radix-ui/react-aspect-ratio": "^1.1.7",
  "@radix-ui/react-avatar": "^1.1.10",
  "@radix-ui/react-checkbox": "^1.3.2",
  "@radix-ui/react-collapsible": "^1.1.11",
  "@radix-ui/react-context-menu": "^2.2.15",
  "@radix-ui/react-dialog": "^1.1.14",
  "@radix-ui/react-dropdown-menu": "^2.1.15",
  "@radix-ui/react-hover-card": "^1.1.14",
  "@radix-ui/react-label": "^2.1.7",
  "@radix-ui/react-menubar": "^1.1.15",
  "@radix-ui/react-navigation-menu": "^1.2.13",
  "@radix-ui/react-popover": "^1.1.14",
  "@radix-ui/react-progress": "^1.1.7",
  "@radix-ui/react-radio-group": "^1.3.7",
  "@radix-ui/react-scroll-area": "^1.2.9",
  "@radix-ui/react-select": "^2.2.5",
  "@radix-ui/react-separator": "^1.1.7",
  "@radix-ui/react-slider": "^1.3.5",
  "@radix-ui/react-slot": "^1.2.3",
  "@radix-ui/react-switch": "^1.2.5",
  "@radix-ui/react-tabs": "^1.1.12",
  "@radix-ui/react-toast": "^1.2.14",
  "@radix-ui/react-toggle": "^1.1.9",
  "@radix-ui/react-toggle-group": "^1.1.10",
  "@radix-ui/react-tooltip": "^1.2.7",
  "@supabase/supabase-js": "^2.76.1",
  "@tanstack/react-query": "^5.83.0",
  "class-variance-authority": "^0.7.1",
  "clsx": "^2.1.1",
  "cmdk": "^1.1.1",
  "date-fns": "^3.6.0",
  "embla-carousel-react": "^8.6.0",
  "input-otp": "^1.4.2",
  "lucide-react": "^0.462.0",
  "next-themes": "^0.3.0",
  "react": "^18.3.1",
  "react-day-picker": "^8.10.1",
  "react-dom": "^18.3.1",
  "react-hook-form": "^7.61.1",
  "react-resizable-panels": "^2.1.9",
  "react-router-dom": "^6.30.1",
  "recharts": "^2.15.4",
  "sonner": "^1.7.4",
  "tailwind-merge": "^2.6.0",
  "tailwindcss-animate": "^1.0.7",
  "vaul": "^0.9.9",
  "zod": "^3.25.76"
}
{
  "@eslint/js": "^9.32.0",
  "@tailwindcss/typography": "^0.5.16",
  "@types/node": "^22.16.5",
  "@types/react": "^18.3.23",
  "@types/react-dom": "^18.3.7",
  "@vitejs/plugin-react-swc": "^3.11.0",
  "autoprefixer": "^10.4.21",
  "eslint": "^9.32.0",
  "eslint-plugin-react-hooks": "^5.2.0",
  "eslint-plugin-react-refresh": "^0.4.20",
  "globals": "^15.15.0",
  "lovable-tagger": "^1.1.11",
  "postcss": "^8.5.6",
  "tailwindcss": "^3.4.17",
  "typescript": "^5.8.3",
  "typescript-eslint": "^8.38.0",
  "vite": "^5.4.19"
}

VITE_SUPABASE_PROJECT_ID="korfuodesmuvloncrpmn"
VITE_SUPABASE_PUBLISHABLE_KEY="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImtvcmZ1b2Rlc211dmxvbmNycG1uIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjEyOTI0MjgsImV4cCI6MjA3Njg2ODQyOH0.c8tZ7CU8_bqjA27pgjdBNYClyzZdUpcGTcxfCssm7Ig"
VITE_SUPABASE_URL="https://korfuodesmuvloncrpmn.supabase.co"

export type Json =
  | string
  | number
  | boolean
  | null
  | { [key: string]: Json | undefined }
  | Json[]

export type Database = {
  // Allows to automatically instantiate createClient with right options
  // instead of createClient<Database, { PostgrestVersion: 'XX' }>(URL, KEY)
  __InternalSupabase: {
    PostgrestVersion: "13.0.5"
  }
  public: {
    Tables: {
      evolution_api_history: {
        Row: {
          created_at: string
          event_type: string
          id: string
          instance_name: string
          payload: Json | null
          status_code: number | null
        }
        Insert: {
          created_at?: string
          event_type: string
          id?: string
          instance_name: string
          payload?: Json | null
          status_code?: number | null
        }
        Update: {
          created_at?: string
          event_type?: string
          id?: string
          instance_name?: string
          payload?: Json | null
          status_code?: number | null
        }
        Relationships: []
      }
      evolution_logout_history: {
        Row: {
          created_at: string
          id: string
          instance_name: string
          request_payload: Json | null
          response_status: number | null
          user_id: string
        }
        Insert: {
          created_at?: string
          id?: string
          instance_name: string
          request_payload?: Json | null
          response_status?: number | null
          user_id: string
        }
        Update: {
          created_at?: string
          id?: string
          instance_name?: string
          request_payload?: Json | null
          response_status?: number | null
          user_id?: string
        }
        Relationships: []
      }
      n8n_message_sender_history: {
        Row: {
          created_at: string
          id: string
          instance_name: string
          message_text: string
          recipient_phone: string
          request_payload: Json | null
          response_status: number | null
          user_id: string
        }
        Insert: {
          created_at?: string
          id?: string
          instance_name: string
          message_text: string
          recipient_phone: string
          request_payload?: Json | null
          response_status?: number | null
          user_id: string
        }
        Update: {
          created_at?: string
          id?: string
          instance_name?: string
          message_text?: string
          recipient_phone?: string
          request_payload?: Json | null
          response_status?: number | null
          user_id?: string
        }
        Relationships: []
      }
      n8n_qr_code_history: {
        Row: {
          created_at: string
          id: string
          instance_name: string
          request_payload: Json | null
          response_data: Json | null
          response_status: number | null
          user_id: string
        }
        Insert: {
          created_at?: string
          id?: string
          instance_name: string
          request_payload?: Json | null
          response_data?: Json | null
          response_status?: number | null
          user_id: string
        }
        Update: {
          created_at?: string
          id?: string
          instance_name?: string
          request_payload?: Json | null
          response_data?: Json | null
          response_status?: number | null
          user_id?: string
        }
        Relationships: []
      }
      planos: {
        Row: {
          created_at: string
          id: string
          nome: string
          updated_at: string
          valor: number
        }
        Insert: {
          created_at?: string
          id?: string
          nome: string
          updated_at?: string
          valor?: number
        }
        Update: {
          created_at?: string
          id?: string
          nome?: string
          updated_at?: string
          valor?: number
        }
        Relationships: []
      }
      profiles: {
        Row: {
          cpf: string
          created_at: string
          created_by: string | null
          email: string | null
          expiry_date: string | null
          full_name: string | null
          id: string
          phone: string
          pix_key: string | null
          plan_id: string | null
          status: string | null
          updated_at: string
          user_id: string
        }
        Insert: {
          cpf?: string
          created_at?: string
          created_by?: string | null
          email?: string | null
          expiry_date?: string | null
          full_name?: string | null
          id?: string
          phone?: string
          pix_key?: string | null
          plan_id?: string | null
          status?: string | null
          updated_at?: string
          user_id: string
        }
        Update: {
          cpf?: string
          created_at?: string
          created_by?: string | null
          email?: string | null
          expiry_date?: string | null
          full_name?: string | null
          id?: string
          phone?: string
          pix_key?: string | null
          plan_id?: string | null
          status?: string | null
          updated_at?: string
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "fk_profiles_plan_id"
            columns: ["plan_id"]
            isOneToOne: false
            referencedRelation: "planos"
            referencedColumns: ["id"]
          },
        ]
      }
      templates: {
        Row: {
          assunto: string | null
          corpo: string
          created_at: string
          id: string
          nome: string
          tipo: string
          updated_at: string
          user_id: string
        }
        Insert: {
          assunto?: string | null
          corpo: string
          created_at?: string
          id?: string
          nome: string
          tipo?: string
          updated_at?: string
          user_id?: string
        }
        Update: {
          assunto?: string | null
          corpo?: string
          created_at?: string
          id?: string
          nome?: string
          tipo?: string
          updated_at?: string
          user_id?: string
        }
        Relationships: []
      }
      user_instances: {
        Row: {
          connection_status: string
          created_at: string
          id: string
          instance_name: string
          last_connected_at: string | null
          qr_code_base64: string | null
          updated_at: string
          user_id: string
        }
        Insert: {
          connection_status?: string
          created_at?: string
          id?: string
          instance_name: string
          last_connected_at?: string | null
          qr_code_base64?: string | null
          updated_at?: string
          user_id: string
        }
        Update: {
          connection_status?: string
          created_at?: string
          id?: string
          instance_name?: string
          last_connected_at?: string | null
          qr_code_base64?: string | null
          updated_at?: string
          user_id?: string
        }
        Relationships: []
      }
      user_roles: {
        Row: {
          created_at: string
          id: string
          role: Database["public"]["Enums"]["app_role"]
          updated_at: string
          user_id: string
        }
        Insert: {
          created_at?: string
          id?: string
          role: Database["public"]["Enums"]["app_role"]
          updated_at?: string
          user_id: string
        }
        Update: {
          created_at?: string
          id?: string
          role?: Database["public"]["Enums"]["app_role"]
          updated_at?: string
          user_id?: string
        }
        Relationships: []
      }
      webhook_configs: {
        Row: {
          config_key: string
          created_at: string
          description: string | null
          id: string
          updated_at: string
          webhook_url: string
        }
        Insert: {
          config_key: string
          created_at?: string
          description?: string | null
          id?: string
          updated_at?: string
          webhook_url: string
        }
        Update: {
          config_key?: string
          created_at?: string
          description?: string | null
          id?: string
          updated_at?: string
          webhook_url?: string
        }
        Relationships: []
      }
    }
    Views: {
      [_ in never]: never
    }
    Functions: {
      has_role: {
        Args: {
          _role: Database["public"]["Enums"]["app_role"]
          _user_id: string
        }
        Returns: boolean
      }
    }
    Enums: {
      app_role: "master" | "reseller"
    }
    CompositeTypes: {
      [_ in never]: never
    }
  }
}

type DatabaseWithoutInternals = Omit<Database, "__InternalSupabase">

type DefaultSchema = DatabaseWithoutInternals[Extract<keyof Database, "public">]

export type Tables<
  DefaultSchemaTableNameOrOptions extends
    | keyof (DefaultSchema["Tables"] & DefaultSchema["Views"])
    | { schema: keyof DatabaseWithoutInternals },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof (DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"] &
        DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Views"])
    : never = never,
> = DefaultSchemaTableNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? (DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"] &
      DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Views"])[TableName] extends {
      Row: infer R
    }
    ? R
    : never
  : DefaultSchemaTableNameOrOptions extends keyof (DefaultSchema["Tables"] &
        DefaultSchema["Views"])
    ? (DefaultSchema["Tables"] &
        DefaultSchema["Views"])[DefaultSchemaTableNameOrOptions] extends {
        Row: infer R
      }
      ? R
      : never
    : never

export type TablesInsert<
  DefaultSchemaTableNameOrOptions extends
    | keyof DefaultSchema["Tables"]
    | { schema: keyof DatabaseWithoutInternals },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"]
    : never = never,
> = DefaultSchemaTableNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"][TableName] extends {
      Insert: infer I
    }
    ? I
    : never
  : DefaultSchemaTableNameOrOptions extends keyof DefaultSchema["Tables"]
    ? DefaultSchema["Tables"][DefaultSchemaTableNameOrOptions] extends {
        Insert: infer I
      }
      ? I
      : never
    : never

export type TablesUpdate<
  DefaultSchemaTableNameOrOptions extends
    | keyof DefaultSchema["Tables"]
    | { schema: keyof DatabaseWithoutInternals },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"]
    : never = never,
> = DefaultSchemaTableNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"][TableName] extends {
      Update: infer U
    }
    ? U
    : never
  : DefaultSchemaTableNameOrOptions extends keyof DefaultSchema["Tables"]
    ? DefaultSchema["Tables"][DefaultSchemaTableNameOrOptions] extends {
        Update: infer U
      }
      ? U
      : never
    : never

export type Enums<
  DefaultSchemaEnumNameOrOptions extends
    | keyof DefaultSchema["Enums"]
    | { schema: keyof DatabaseWithoutInternals },
  EnumName extends DefaultSchemaEnumNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof DatabaseWithoutInternals[DefaultSchemaEnumNameOrOptions["schema"]]["Enums"]
    : never = never,
> = DefaultSchemaEnumNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? DatabaseWithoutInternals[DefaultSchemaEnumNameOrOptions["schema"]]["Enums"][EnumName]
  : DefaultSchemaEnumNameOrOptions extends keyof DefaultSchema["Enums"]
    ? DefaultSchema["Enums"][DefaultSchemaEnumNameOrOptions]
    : never

export type CompositeTypes<
  PublicCompositeTypeNameOrOptions extends
    | keyof DefaultSchema["CompositeTypes"]
    | { schema: keyof DatabaseWithoutInternals },
  CompositeTypeName extends PublicCompositeTypeNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof DatabaseWithoutInternals[PublicCompositeTypeNameOrOptions["schema"]]["CompositeTypes"]
    : never = never,
> = PublicCompositeTypeNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? DatabaseWithoutInternals[PublicCompositeTypeNameOrOptions["schema"]]["CompositeTypes"][CompositeTypeName]
  : PublicCompositeTypeNameOrOptions extends keyof DefaultSchema["CompositeTypes"]
    ? DefaultSchema["CompositeTypes"][PublicCompositeTypeNameOrOptions]
    : never

export const Constants = {
  public: {
    Enums: {
      app_role: ["master", "reseller"],
    },
  },
} as const

import { Toaster } from "@/components/ui/toaster";
import { Toaster as Sonner } from "@/components/ui/sonner";
import { TooltipProvider } from "@/components/ui/tooltip";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { BrowserRouter, Routes, Route } from "react-router-dom";
import { SidebarProvider } from "@/components/ui/sidebar";
import { AppSidebar } from "@/components/AppSidebar";
import { AuthProvider } from "@/contexts/AuthContext";
import { ProtectedRoute } from "@/components/ProtectedRoute";
import Dashboard from "./pages/Dashboard";
import Planos from "./pages/Planos";
import Configuracoes from "./pages/Configuracoes";
import Revenda from "./pages/Revenda";
import Templates from "./pages/Templates";
import Webhooks from "./pages/Webhooks";
import WhatsAppConnection from "./pages/WhatsAppConnection";
import Auth from "./pages/Auth";
import NotFound from "./pages/NotFound";

const queryClient = new QueryClient();

const App = () => (
  <QueryClientProvider client={queryClient}>
    <TooltipProvider>
      <Toaster />
      <Sonner />
      <BrowserRouter>
        <AuthProvider>
          <Routes>
            <Route path="/auth" element={<Auth />} />
            <Route
              path="/*"
              element={
                <ProtectedRoute>
                  <SidebarProvider>
                    <div className="flex min-h-screen w-full">
                      <AppSidebar />
                      <div className="flex-1">
                        <Routes>
                          <Route path="/" element={<Dashboard />} />
                          <Route path="/planos" element={<Planos />} />
                          <Route path="/revenda" element={<Revenda />} />
                          <Route path="/templates" element={<Templates />} />
                          <Route path="/whatsapp" element={<WhatsAppConnection />} />
                          <Route path="/settings/webhooks" element={<Webhooks />} />
                          <Route path="/configuracoes" element={<Configuracoes />} />
                          <Route path="*" element={<NotFound />} />
                        </Routes>
                      </div>
                    </div>
                  </SidebarProvider>
                </ProtectedRoute>
              }
            />
          </Routes>
        </AuthProvider>
      </BrowserRouter>
    </TooltipProvider>
  </QueryClientProvider>
);

export default App;


--- Conteúdo de: supabase/migrations/20251024172442_67b980cf-a2ee-4a91-8981-9f1c055189aa.sql ---
-- Create profiles table
CREATE TABLE public.profiles (
  id uuid NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id uuid NOT NULL UNIQUE REFERENCES auth.users(id) ON DELETE CASCADE,
  full_name text,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  updated_at timestamp with time zone NOT NULL DEFAULT now()
);

-- Enable Row Level Security
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Create policies for profiles
CREATE POLICY "Users can view their own profile"
  ON public.profiles
  FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can update their own profile"
  ON public.profiles
  FOR UPDATE
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own profile"
  ON public.profiles
  FOR INSERT
  WITH CHECK (auth.uid() = user_id);

-- Create function to handle new user profiles
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  INSERT INTO public.profiles (user_id, full_name)
  VALUES (
    new.id,
    COALESCE(new.raw_user_meta_data->>'full_name', '')
  );
  RETURN new;
END;
$$;

-- Create trigger for new user creation
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW
  EXECUTE FUNCTION public.handle_new_user();

-- Create function to update timestamps
CREATE OR REPLACE FUNCTION public.update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SET search_path = public;

-- Create trigger for automatic timestamp updates
CREATE TRIGGER update_profiles_updated_at
  BEFORE UPDATE ON public.profiles
  FOR EACH ROW
  EXECUTE FUNCTION public.update_updated_at_column();
--- Conteúdo de: supabase/migrations/20251024172806_d771aa55-9c11-4d74-b66b-2a43f03709a0.sql ---
-- Add reseller_role column to profiles table
ALTER TABLE public.profiles 
ADD COLUMN reseller_role text CHECK (reseller_role IN ('master', 'reseller'));

-- Create index for better query performance
CREATE INDEX idx_profiles_reseller_role ON public.profiles(reseller_role);

-- Update RLS policies to allow masters to view all profiles with reseller roles
CREATE POLICY "Masters can view all reseller profiles"
  ON public.profiles
  FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM public.profiles
      WHERE user_id = auth.uid() AND reseller_role = 'master'
    )
    OR auth.uid() = user_id
  );
--- Conteúdo de: supabase/migrations/20251027192502_171389d1-586b-44ed-8a4e-088532457ea7.sql ---
-- Drop existing problematic policies
DROP POLICY IF EXISTS "Masters can view all reseller profiles" ON public.profiles;
DROP POLICY IF EXISTS "Users can view their own profile" ON public.profiles;
DROP POLICY IF EXISTS "Users can insert their own profile" ON public.profiles;
DROP POLICY IF EXISTS "Users can update their own profile" ON public.profiles;

-- Create a security definer function to check reseller role
CREATE OR REPLACE FUNCTION public.get_user_reseller_role(user_id uuid)
RETURNS text
LANGUAGE sql
STABLE
SECURITY DEFINER
SET search_path = public
AS $$
  SELECT reseller_role
  FROM public.profiles
  WHERE profiles.user_id = $1
  LIMIT 1;
$$;

-- Create a security definer function to check if user is master
CREATE OR REPLACE FUNCTION public.is_master(user_id uuid)
RETURNS boolean
LANGUAGE sql
STABLE
SECURITY DEFINER
SET search_path = public
AS $$
  SELECT EXISTS (
    SELECT 1
    FROM public.profiles
    WHERE profiles.user_id = $1
      AND profiles.reseller_role = 'master'
  );
$$;

-- Create new policies using the security definer functions
CREATE POLICY "Users can view their own profile"
  ON public.profiles
  FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Masters can view all profiles"
  ON public.profiles
  FOR SELECT
  USING (public.is_master(auth.uid()));

CREATE POLICY "Users can insert their own profile"
  ON public.profiles
  FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own profile"
  ON public.profiles
  FOR UPDATE
  USING (auth.uid() = user_id);

-- Grant execute permissions on the functions
GRANT EXECUTE ON FUNCTION public.get_user_reseller_role(uuid) TO authenticated;
GRANT EXECUTE ON FUNCTION public.is_master(uuid) TO authenticated;
--- Conteúdo de: supabase/migrations/20251027192813_6f66c686-3cb3-4173-a0ad-d6368fec3f9b.sql ---
-- Drop existing policies on profiles FIRST (before dropping functions)
DROP POLICY IF EXISTS "Users can view their own profile" ON public.profiles;
DROP POLICY IF EXISTS "Masters can view all profiles" ON public.profiles;
DROP POLICY IF EXISTS "Users can insert their own profile" ON public.profiles;
DROP POLICY IF EXISTS "Users can update their own profile" ON public.profiles;

-- NOW drop old security definer functions
DROP FUNCTION IF EXISTS public.get_user_reseller_role(uuid);
DROP FUNCTION IF EXISTS public.is_master(uuid);

-- Create enum for roles
CREATE TYPE public.app_role AS ENUM ('master', 'reseller');

-- Create user_roles table
CREATE TABLE public.user_roles (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
  role app_role NOT NULL,
  created_at timestamp with time zone DEFAULT now() NOT NULL,
  updated_at timestamp with time zone DEFAULT now() NOT NULL,
  UNIQUE(user_id, role)
);

-- Enable RLS on user_roles
ALTER TABLE public.user_roles ENABLE ROW LEVEL SECURITY;

-- Add created_by column to profiles to track who created each reseller
ALTER TABLE public.profiles ADD COLUMN created_by uuid REFERENCES auth.users(id) ON DELETE SET NULL;

-- Migrate existing reseller_role data to user_roles
INSERT INTO public.user_roles (user_id, role)
SELECT user_id, reseller_role::app_role
FROM public.profiles
WHERE reseller_role IS NOT NULL
ON CONFLICT (user_id, role) DO NOTHING;

-- Remove reseller_role column from profiles (no longer needed)
ALTER TABLE public.profiles DROP COLUMN IF EXISTS reseller_role;

-- Create new security definer function to check if user has a role
CREATE OR REPLACE FUNCTION public.has_role(_user_id uuid, _role app_role)
RETURNS boolean
LANGUAGE sql
STABLE
SECURITY DEFINER
SET search_path = public
AS $$
  SELECT EXISTS (
    SELECT 1
    FROM public.user_roles
    WHERE user_id = _user_id
      AND role = _role
  );
$$;

-- Create new policies for profiles
-- Users can view their own profile
CREATE POLICY "Users can view their own profile"
  ON public.profiles
  FOR SELECT
  USING (auth.uid() = user_id);

-- Masters can view profiles they created
CREATE POLICY "Masters can view profiles they created"
  ON public.profiles
  FOR SELECT
  USING (
    public.has_role(auth.uid(), 'master') 
    AND auth.uid() = created_by
  );

-- Users can insert their own profile
CREATE POLICY "Users can insert their own profile"
  ON public.profiles
  FOR INSERT
  WITH CHECK (auth.uid() = user_id);

-- Users can update their own profile
CREATE POLICY "Users can update their own profile"
  ON public.profiles
  FOR UPDATE
  USING (auth.uid() = user_id);

-- Create policies for user_roles
-- Users can view their own roles
CREATE POLICY "Users can view their own roles"
  ON public.user_roles
  FOR SELECT
  USING (auth.uid() = user_id);

-- Masters can view roles (for checking permissions)
CREATE POLICY "Masters can view roles"
  ON public.user_roles
  FOR SELECT
  USING (public.has_role(auth.uid(), 'master'));

-- Trigger for updating updated_at on user_roles
CREATE TRIGGER update_user_roles_updated_at
  BEFORE UPDATE ON public.user_roles
  FOR EACH ROW
  EXECUTE FUNCTION public.update_updated_at_column();

-- Grant permissions
GRANT EXECUTE ON FUNCTION public.has_role(uuid, app_role) TO authenticated;
GRANT USAGE ON TYPE public.app_role TO authenticated;
--- Conteúdo de: supabase/migrations/20251027193838_5c5d133f-a1a0-48a1-a8d8-661e770be033.sql ---
-- Add email, plan, expiry_date, and status columns to profiles table
ALTER TABLE public.profiles 
ADD COLUMN IF NOT EXISTS email TEXT,
ADD COLUMN IF NOT EXISTS plan TEXT,
ADD COLUMN IF NOT EXISTS expiry_date TIMESTAMP WITH TIME ZONE,
ADD COLUMN IF NOT EXISTS status TEXT DEFAULT 'active';

-- Create index on email for faster lookups
CREATE INDEX IF NOT EXISTS idx_profiles_email ON public.profiles(email);

-- Create index on status for filtering
CREATE INDEX IF NOT EXISTS idx_profiles_status ON public.profiles(status);

-- Update existing profiles with email from auth.users (if possible via a function)
-- Note: This will be handled by the edge function for new users
--- Conteúdo de: supabase/migrations/20251027202338_10d08ea8-950b-461d-bea3-a44b29e2b74b.sql ---
-- Criar tabela de planos
CREATE TABLE public.planos (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  nome TEXT NOT NULL UNIQUE,
  valor NUMERIC NOT NULL DEFAULT 0,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
);

-- Habilitar RLS na tabela planos
ALTER TABLE public.planos ENABLE ROW LEVEL SECURITY;

-- Criar política para permitir leitura de planos para usuários autenticados
CREATE POLICY "Usuários autenticados podem visualizar planos"
ON public.planos
FOR SELECT
TO authenticated
USING (true);

-- Criar política para permitir masters gerenciar planos
CREATE POLICY "Masters podem inserir planos"
ON public.planos
FOR INSERT
TO authenticated
WITH CHECK (has_role(auth.uid(), 'master'));

CREATE POLICY "Masters podem atualizar planos"
ON public.planos
FOR UPDATE
TO authenticated
USING (has_role(auth.uid(), 'master'));

CREATE POLICY "Masters podem deletar planos"
ON public.planos
FOR DELETE
TO authenticated
USING (has_role(auth.uid(), 'master'));

-- Adicionar trigger para atualizar updated_at
CREATE TRIGGER update_planos_updated_at
BEFORE UPDATE ON public.planos
FOR EACH ROW
EXECUTE FUNCTION public.update_updated_at_column();

-- Renomear e modificar coluna plan na tabela profiles
ALTER TABLE public.profiles 
RENAME COLUMN plan TO plan_id;

ALTER TABLE public.profiles 
ALTER COLUMN plan_id TYPE UUID USING NULL;

-- Adicionar foreign key
ALTER TABLE public.profiles
ADD CONSTRAINT fk_profiles_plan_id
FOREIGN KEY (plan_id)
REFERENCES public.planos(id)
ON DELETE SET NULL;
--- Conteúdo de: supabase/migrations/20251027203423_67d3aa70-7d6e-4556-af72-409014b08ff9.sql ---
-- Criar tabela de templates
CREATE TABLE public.templates (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  nome TEXT NOT NULL,
  assunto TEXT,
  corpo TEXT NOT NULL,
  tipo TEXT NOT NULL DEFAULT 'global',
  user_id UUID NOT NULL DEFAULT auth.uid(),
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
);

-- Habilitar RLS na tabela templates
ALTER TABLE public.templates ENABLE ROW LEVEL SECURITY;

-- Criar política para permitir leitura de templates para usuários autenticados
CREATE POLICY "Usuários autenticados podem visualizar templates"
ON public.templates
FOR SELECT
TO authenticated
USING (true);

-- Criar política para permitir masters criar templates
CREATE POLICY "Masters podem inserir templates"
ON public.templates
FOR INSERT
TO authenticated
WITH CHECK (has_role(auth.uid(), 'master'));

-- Criar política para permitir masters atualizar templates
CREATE POLICY "Masters podem atualizar templates"
ON public.templates
FOR UPDATE
TO authenticated
USING (has_role(auth.uid(), 'master'));

-- Criar política para permitir masters deletar templates
CREATE POLICY "Masters podem deletar templates"
ON public.templates
FOR DELETE
TO authenticated
USING (has_role(auth.uid(), 'master'));

-- Adicionar trigger para atualizar updated_at
CREATE TRIGGER update_templates_updated_at
BEFORE UPDATE ON public.templates
FOR EACH ROW
EXECUTE FUNCTION public.update_updated_at_column();
--- Conteúdo de: supabase/migrations/20251027204334_ffa8362d-cda5-4ec2-8b0e-0695769076ae.sql ---
-- Criar tabela webhook_configs para armazenar URLs dos webhooks do n8n
CREATE TABLE public.webhook_configs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  config_key TEXT NOT NULL UNIQUE,
  webhook_url TEXT NOT NULL,
  description TEXT,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
);

-- Habilitar RLS
ALTER TABLE public.webhook_configs ENABLE ROW LEVEL SECURITY;

-- Políticas: Apenas masters podem gerenciar
CREATE POLICY "Masters podem visualizar webhook configs"
ON public.webhook_configs
FOR SELECT
TO authenticated
USING (has_role(auth.uid(), 'master'));

CREATE POLICY "Masters podem inserir webhook configs"
ON public.webhook_configs
FOR INSERT
TO authenticated
WITH CHECK (has_role(auth.uid(), 'master'));

CREATE POLICY "Masters podem atualizar webhook configs"
ON public.webhook_configs
FOR UPDATE
TO authenticated
USING (has_role(auth.uid(), 'master'));

CREATE POLICY "Masters podem deletar webhook configs"
ON public.webhook_configs
FOR DELETE
TO authenticated
USING (has_role(auth.uid(), 'master'));

-- Criar tabela user_instances para instâncias do WhatsApp
CREATE TABLE public.user_instances (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL UNIQUE REFERENCES auth.users(id) ON DELETE CASCADE,
  instance_name TEXT NOT NULL UNIQUE,
  connection_status TEXT NOT NULL DEFAULT 'disconnected',
  qr_code_base64 TEXT,
  last_connected_at TIMESTAMP WITH TIME ZONE,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
);

-- Habilitar RLS e Realtime
ALTER TABLE public.user_instances ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_instances REPLICA IDENTITY FULL;

-- Políticas
CREATE POLICY "Usuários podem ver sua própria instância"
ON public.user_instances
FOR SELECT
TO authenticated
USING (auth.uid() = user_id);

CREATE POLICY "Masters podem ver todas as instâncias"
ON public.user_instances
FOR SELECT
TO authenticated
USING (has_role(auth.uid(), 'master'));

CREATE POLICY "Usuários podem inserir sua própria instância"
ON public.user_instances
FOR INSERT
TO authenticated
WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Usuários podem atualizar sua própria instância"
ON public.user_instances
FOR UPDATE
TO authenticated
USING (auth.uid() = user_id);

-- Criar tabela evolution_api_history
CREATE TABLE public.evolution_api_history (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  instance_name TEXT NOT NULL,
  event_type TEXT NOT NULL,
  status_code INTEGER,
  payload JSONB,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
);

ALTER TABLE public.evolution_api_history ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Masters podem ver histórico da Evolution API"
ON public.evolution_api_history
FOR SELECT
TO authenticated
USING (has_role(auth.uid(), 'master'));

-- Criar tabela n8n_qr_code_history
CREATE TABLE public.n8n_qr_code_history (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  instance_name TEXT NOT NULL,
  request_payload JSONB,
  response_status INTEGER,
  response_data JSONB,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
);

ALTER TABLE public.n8n_qr_code_history ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Usuários podem ver seu próprio histórico QR"
ON public.n8n_qr_code_history
FOR SELECT
TO authenticated
USING (auth.uid() = user_id);

CREATE POLICY "Masters podem ver todo histórico QR"
ON public.n8n_qr_code_history
FOR SELECT
TO authenticated
USING (has_role(auth.uid(), 'master'));

-- Criar tabela evolution_logout_history
CREATE TABLE public.evolution_logout_history (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  instance_name TEXT NOT NULL,
  request_payload JSONB,
  response_status INTEGER,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
);

ALTER TABLE public.evolution_logout_history ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Usuários podem ver seu próprio histórico logout"
ON public.evolution_logout_history
FOR SELECT
TO authenticated
USING (auth.uid() = user_id);

CREATE POLICY "Masters podem ver todo histórico logout"
ON public.evolution_logout_history
FOR SELECT
TO authenticated
USING (has_role(auth.uid(), 'master'));

-- Criar tabela n8n_message_sender_history
CREATE TABLE public.n8n_message_sender_history (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  instance_name TEXT NOT NULL,
  recipient_phone TEXT NOT NULL,
  message_text TEXT NOT NULL,
  request_payload JSONB,
  response_status INTEGER,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
);

ALTER TABLE public.n8n_message_sender_history ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Usuários podem ver seu próprio histórico de mensagens"
ON public.n8n_message_sender_history
FOR SELECT
TO authenticated
USING (auth.uid() = user_id);

CREATE POLICY "Masters podem ver todo histórico de mensagens"
ON public.n8n_message_sender_history
FOR SELECT
TO authenticated
USING (has_role(auth.uid(), 'master'));

-- Adicionar triggers para updated_at
CREATE TRIGGER update_webhook_configs_updated_at
BEFORE UPDATE ON public.webhook_configs
FOR EACH ROW
EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_user_instances_updated_at
BEFORE UPDATE ON public.user_instances
FOR EACH ROW
EXECUTE FUNCTION public.update_updated_at_column();
--- Conteúdo de: supabase/migrations/20251027211430_c14cfc0f-45a5-4881-826c-c6a9ae93a9cc.sql ---
-- Adicionar políticas INSERT para histórico
-- Permitir que usuários autenticados insiram seus próprios registros de histórico

-- n8n_qr_code_history
CREATE POLICY "Usuários podem inserir seu próprio histórico QR"
ON public.n8n_qr_code_history
FOR INSERT
TO authenticated
WITH CHECK (auth.uid() = user_id);

-- n8n_message_sender_history  
CREATE POLICY "Usuários podem inserir seu próprio histórico de mensagens"
ON public.n8n_message_sender_history
FOR INSERT
TO authenticated
WITH CHECK (auth.uid() = user_id);

-- evolution_logout_history
CREATE POLICY "Usuários podem inserir seu próprio histórico logout"
ON public.evolution_logout_history
FOR INSERT
TO authenticated
WITH CHECK (auth.uid() = user_id);

-- evolution_api_history (apenas service_role pode inserir, pois vem do webhook)
CREATE POLICY "Service role pode inserir histórico Evolution API"
ON public.evolution_api_history
FOR INSERT
TO service_role
WITH CHECK (true);

-- Configurar Realtime para user_instances
ALTER TABLE public.user_instances REPLICA IDENTITY FULL;

-- Adicionar à publicação realtime se não estiver
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_publication_tables 
    WHERE pubname = 'supabase_realtime' 
    AND tablename = 'user_instances'
  ) THEN
    ALTER PUBLICATION supabase_realtime ADD TABLE public.user_instances;
  END IF;
END $$;
--- Conteúdo de: supabase/migrations/20251027222923_af059369-6b22-4dff-abc5-0fdf4ee1bb1b.sql ---
-- Add cpf (required) and pix_key to profiles with safe defaults
ALTER TABLE public.profiles
ADD COLUMN IF NOT EXISTS cpf TEXT NOT NULL DEFAULT '';

ALTER TABLE public.profiles
ADD COLUMN IF NOT EXISTS pix_key TEXT;

-- Optional: create index for lookups by user_id (already exists) and cpf for uniqueness later if needed
-- Note: Not enforcing uniqueness of cpf now to avoid blocking existing data

--- Conteúdo de: supabase/migrations/20251027224604_59a7a3a1-bf8c-4be3-82e4-23b0a9ed3f42.sql ---
-- Adicionar coluna phone à tabela profiles (se não existir)
ALTER TABLE public.profiles ADD COLUMN IF NOT EXISTS phone TEXT;

-- Atualizar coluna para NOT NULL com valor padrão para registros existentes
UPDATE public.profiles SET phone = '' WHERE phone IS NULL;
ALTER TABLE public.profiles ALTER COLUMN phone SET NOT NULL;
ALTER TABLE public.profiles ALTER COLUMN phone SET DEFAULT '';
======================================
  EXTRA: CONTEÚDO DAS EDGE FUNCTIONS, PÁGINAS E HOOKS
======================================

--- Conteúdo de: supabase/functions/create-reseller-user/index.ts ---
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.76.1";

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req) => {
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    // Create Supabase client with service role key
    const supabaseUrl = Deno.env.get('SUPABASE_URL')!;
    const supabaseServiceKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!;
    
    const supabaseAdmin = createClient(supabaseUrl, supabaseServiceKey, {
      auth: {
        autoRefreshToken: false,
        persistSession: false
      }
    });

    // Get the request body
    const { email, password, fullName, resellerRole } = await req.json();

    console.log('Creating reseller user:', { email, fullName, resellerRole });

    // Validate inputs
    if (!email || !password || !fullName || !resellerRole) {
      throw new Error('Missing required fields');
    }

    if (!['master', 'reseller'].includes(resellerRole)) {
      throw new Error('Invalid reseller role');
    }

    // Check if the requesting user is a master
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      throw new Error('No authorization header');
    }

    const token = authHeader.replace('Bearer ', '');

    const supabaseAnonKey = Deno.env.get('SUPABASE_ANON_KEY') || Deno.env.get('SUPABASE_PUBLISHABLE_KEY');
    if (!supabaseAnonKey) {
      throw new Error('Missing SUPABASE_ANON_KEY');
    }

    const supabaseClient = createClient(supabaseUrl, supabaseAnonKey, {
      auth: {
        autoRefreshToken: false,
        persistSession: false
      },
      global: {
        headers: {
          Authorization: authHeader
        }
      }
    });

    const { data: { user: requestingUser } } = await supabaseClient.auth.getUser(token);
    
    if (!requestingUser) {
      throw new Error('Unauthorized');
    }

    // Check if requesting user is a master
    const { data: requestingRole } = await supabaseAdmin
      .from('user_roles')
      .select('role')
      .eq('user_id', requestingUser.id)
      .eq('role', 'master')
      .maybeSingle();

    if (!requestingRole) {
      throw new Error('Only master users can create reseller accounts');
    }

    // Create the user using admin API
    const { data: newUser, error: createError } = await supabaseAdmin.auth.admin.createUser({
      email,
      password,
      email_confirm: true, // Auto-confirm email
      user_metadata: {
        full_name: fullName
      }
    });

    if (createError) {
      console.error('Error creating user:', createError);
      throw createError;
    }

    console.log('User created successfully:', newUser.user?.id);

    // Create profile with created_by tracking and email
    const { error: profileError } = await supabaseAdmin
      .from('profiles')
      .upsert({ 
        user_id: newUser.user!.id, 
        full_name: fullName,
        email: email,
        created_by: requestingUser.id,
        status: 'active'
      }, { onConflict: 'user_id' });

    if (profileError) {
      console.error('Error upserting profile:', profileError);
      throw profileError;
    }

    console.log('Profile created');

    // Insert role in user_roles table
    const { error: roleError } = await supabaseAdmin
      .from('user_roles')
      .insert({ 
        user_id: newUser.user!.id, 
        role: resellerRole 
      });

    if (roleError) {
      console.error('Error inserting role:', roleError);
      throw roleError;
    }

    console.log('Role assigned successfully');

    return new Response(
      JSON.stringify({ 
        success: true, 
        user: {
          id: newUser.user?.id,
          email: newUser.user?.email
        }
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 200,
      }
    );
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'An error occurred while creating the reseller user';
    console.error('Error in create-reseller-user function:', error);
    return new Response(
      JSON.stringify({ 
        error: errorMessage
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 400,
      }
    );
  }
});

--- Conteúdo de: supabase/functions/delete-reseller-user/index.ts ---
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.76.1";

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const supabaseUrl = Deno.env.get('SUPABASE_URL')!;
    const supabaseServiceKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!;
    
    const supabaseAdmin = createClient(supabaseUrl, supabaseServiceKey, {
      auth: {
        autoRefreshToken: false,
        persistSession: false
      }
    });

    const { userId } = await req.json();

    console.log('Deleting reseller user:', { userId });

    if (!userId) {
      throw new Error('User ID is required');
    }

    // Check if the requesting user is a master
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      throw new Error('No authorization header');
    }

    const token = authHeader.replace('Bearer ', '');
    const supabaseAnonKey = Deno.env.get('SUPABASE_ANON_KEY') || Deno.env.get('SUPABASE_PUBLISHABLE_KEY');
    if (!supabaseAnonKey) {
      throw new Error('Missing SUPABASE_ANON_KEY');
    }

    const supabaseClient = createClient(supabaseUrl, supabaseAnonKey, {
      auth: {
        autoRefreshToken: false,
        persistSession: false
      },
      global: {
        headers: {
          Authorization: authHeader
        }
      }
    });

    const { data: { user: requestingUser } } = await supabaseClient.auth.getUser(token);
    
    if (!requestingUser) {
      throw new Error('Unauthorized');
    }

    // Check if requesting user is a master
    const { data: requestingRole } = await supabaseAdmin
      .from('user_roles')
      .select('role')
      .eq('user_id', requestingUser.id)
      .eq('role', 'master')
      .maybeSingle();

    if (!requestingRole) {
      throw new Error('Only master users can delete reseller accounts');
    }

    // Delete the user using admin API
    const { error: deleteError } = await supabaseAdmin.auth.admin.deleteUser(userId);

    if (deleteError) {
      console.error('Error deleting user:', deleteError);
      throw deleteError;
    }

    console.log('User deleted successfully');

    return new Response(
      JSON.stringify({ 
        success: true
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 200,
      }
    );
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'An error occurred while deleting the reseller user';
    console.error('Error in delete-reseller-user function:', error);
    return new Response(
      JSON.stringify({ 
        error: errorMessage
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 400,
      }
    );
  }
});

--- Conteúdo de: supabase/functions/evolution-webhook-receiver/index.ts ---
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.76.1";

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const supabaseUrl = Deno.env.get('SUPABASE_URL')!;
    const supabaseServiceKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!;
    
    const supabase = createClient(supabaseUrl, supabaseServiceKey);

    const payload = await req.json();
    console.log('Received Evolution API webhook:', JSON.stringify(payload, null, 2));

    // Normalizar payload (pode ser array ou objeto)
    const webhookData = Array.isArray(payload) ? payload[0] : payload;
    
    // Extrair dados do webhook (compatível com múltiplos formatos)
    const instanceName = webhookData?.instance?.instanceName
      ?? webhookData?.instance
      ?? webhookData?.data?.instance
      ?? webhookData?.data?.instanceName;

    const state = webhookData?.instance?.state
      ?? webhookData?.data?.state
      ?? webhookData?.state;

    const event = webhookData?.event ?? webhookData?.type ?? 'connection.update';

    if (!instanceName) {
      console.error('Missing instanceName in webhook payload');
      return new Response(
        JSON.stringify({ error: 'Missing instanceName' }),
        { headers: { ...corsHeaders, 'Content-Type': 'application/json' }, status: 400 }
      );
    }

    // Logar no histórico
    const { error: historyError } = await supabase
      .from('evolution_api_history')
      .insert({
        instance_name: instanceName,
        event_type: event,
        status_code: 200,
        payload: payload
      });

    if (historyError) {
      console.error('Error logging to history:', historyError);
    } else {
      console.log(`Logged to history for instance: ${instanceName}`);
    }

    // Determinar status da conexão baseado no state
    let connectionStatus = 'disconnected';
    let qrCodeBase64 = null;
    let lastConnectedAt = null;

    if (state === 'connecting') {
      connectionStatus = 'connecting';
    } else if (state === 'open') {
      connectionStatus = 'connected';
      lastConnectedAt = new Date().toISOString();
    } else if (state === 'close') {
      connectionStatus = 'disconnected';
    }

    console.log(`Updating instance ${instanceName} to status: ${connectionStatus}`);

    // Atualizar user_instances
    const { error: updateError } = await supabase
      .from('user_instances')
      .update({
        connection_status: connectionStatus,
        qr_code_base64: qrCodeBase64,
        last_connected_at: lastConnectedAt,
      })
      .eq('instance_name', instanceName);

    if (updateError) {
      console.error('Error updating user_instances:', updateError);
      throw updateError;
    }

    console.log(`Successfully updated instance ${instanceName}`);

    return new Response(
      JSON.stringify({ success: true, message: 'Webhook processed' }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 200,
      }
    );
  } catch (error) {
    console.error('Error processing webhook:', error);
    return new Response(
      JSON.stringify({ 
        error: error instanceof Error ? error.message : 'Unknown error'
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 500,
      }
    );
  }
});

--- Conteúdo de: supabase/functions/log-n8n-qr-interaction/index.ts ---
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.76.1";

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const supabaseUrl = Deno.env.get('SUPABASE_URL')!;
    const supabaseAnonKey = Deno.env.get('SUPABASE_ANON_KEY') || Deno.env.get('SUPABASE_PUBLISHABLE_KEY');
    
    if (!supabaseAnonKey) {
      throw new Error('Missing SUPABASE_ANON_KEY');
    }

    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      throw new Error('No authorization header');
    }

    const supabase = createClient(supabaseUrl, supabaseAnonKey, {
      auth: {
        autoRefreshToken: false,
        persistSession: false
      },
      global: {
        headers: {
          Authorization: authHeader
        }
      }
    });

    const { data: { user } } = await supabase.auth.getUser();
    
    if (!user) {
      throw new Error('Unauthorized');
    }

    const { instanceName, requestPayload, responseStatus, responseData } = await req.json();

    console.log('Logging QR interaction for user:', user.id, 'instance:', instanceName);

    const { error } = await supabase
      .from('n8n_qr_code_history')
      .insert({
        user_id: user.id,
        instance_name: instanceName,
        request_payload: requestPayload,
        response_status: responseStatus,
        response_data: responseData
      });

    if (error) throw error;

    return new Response(
      JSON.stringify({ success: true }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 200,
      }
    );
  } catch (error) {
    console.error('Error logging QR interaction:', error);
    return new Response(
      JSON.stringify({ 
        error: error instanceof Error ? error.message : 'Unknown error'
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 400,
      }
    );
  }
});

--- Conteúdo de: supabase/functions/update-reseller-user/index.ts ---
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.76.1";

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const supabaseUrl = Deno.env.get('SUPABASE_URL')!;
    const supabaseServiceKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!;
    
    const supabaseAdmin = createClient(supabaseUrl, supabaseServiceKey, {
      auth: {
        autoRefreshToken: false,
        persistSession: false
      }
    });

    const { userId, email, fullName, phone, password, planId, expiryDate, status } = await req.json();

    console.log('Updating reseller user:', { userId, email, fullName, phone });

    if (!userId) {
      throw new Error('User ID is required');
    }

    // Check if the requesting user is a master
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      throw new Error('No authorization header');
    }

    const token = authHeader.replace('Bearer ', '');
    const supabaseAnonKey = Deno.env.get('SUPABASE_ANON_KEY') || Deno.env.get('SUPABASE_PUBLISHABLE_KEY');
    if (!supabaseAnonKey) {
      throw new Error('Missing SUPABASE_ANON_KEY');
    }

    const supabaseClient = createClient(supabaseUrl, supabaseAnonKey, {
      auth: {
        autoRefreshToken: false,
        persistSession: false
      },
      global: {
        headers: {
          Authorization: authHeader
        }
      }
    });

    const { data: { user: requestingUser } } = await supabaseClient.auth.getUser(token);
    
    if (!requestingUser) {
      throw new Error('Unauthorized');
    }

    // Check if requesting user is a master
    const { data: requestingRole } = await supabaseAdmin
      .from('user_roles')
      .select('role')
      .eq('user_id', requestingUser.id)
      .eq('role', 'master')
      .maybeSingle();

    if (!requestingRole) {
      throw new Error('Only master users can update reseller accounts');
    }

    // Update auth user if email or password changed
    const updateData: any = {};
    if (email) updateData.email = email;
    if (password) updateData.password = password;

    if (Object.keys(updateData).length > 0) {
      const { error: authError } = await supabaseAdmin.auth.admin.updateUserById(
        userId,
        updateData
      );

      if (authError) {
        console.error('Error updating auth user:', authError);
        throw authError;
      }
    }

    // Update profile
    const profileUpdate: any = {};
    if (fullName) profileUpdate.full_name = fullName;
    if (email) profileUpdate.email = email;
    if (phone) profileUpdate.phone = phone;
    if (planId !== undefined) profileUpdate.plan_id = planId;
    if (expiryDate !== undefined) profileUpdate.expiry_date = expiryDate;
    if (status !== undefined) profileUpdate.status = status;

    if (Object.keys(profileUpdate).length > 0) {
      const { error: profileError } = await supabaseAdmin
        .from('profiles')
        .update(profileUpdate)
        .eq('user_id', userId);

      if (profileError) {
        console.error('Error updating profile:', profileError);
        throw profileError;
      }
    }

    console.log('User updated successfully');

    return new Response(
      JSON.stringify({ 
        success: true
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 200,
      }
    );
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'An error occurred while updating the reseller user';
    console.error('Error in update-reseller-user function:', error);
    return new Response(
      JSON.stringify({ 
        error: errorMessage
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 400,
      }
    );
  }
});

--- Conteúdo de: src/pages/Auth.tsx ---
import { useState, useEffect } from "react";
import { useNavigate } from "react-router-dom";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import * as z from "zod";
import { useAuth } from "@/contexts/AuthContext";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Avatar, AvatarFallback } from "@/components/ui/avatar";
import { useToast } from "@/hooks/use-toast";

const signInSchema = z.object({
  email: z.string().email("E-mail inválido"),
  password: z.string().min(6, "A senha deve ter no mínimo 6 caracteres"),
});

const signUpSchema = z.object({
  fullName: z.string().min(3, "Nome deve ter no mínimo 3 caracteres"),
  email: z.string().email("E-mail inválido"),
  password: z.string().min(6, "A senha deve ter no mínimo 6 caracteres"),
});

type SignInFormData = z.infer<typeof signInSchema>;
type SignUpFormData = z.infer<typeof signUpSchema>;

export default function Auth() {
  const [activeTab, setActiveTab] = useState("signin");
  const { signIn, signUp, user } = useAuth();
  const navigate = useNavigate();
  const { toast } = useToast();

  useEffect(() => {
    if (user) {
      navigate("/");
    }
  }, [user, navigate]);

  const signInForm = useForm<SignInFormData>({
    resolver: zodResolver(signInSchema),
    defaultValues: {
      email: "",
      password: "",
    },
  });

  const signUpForm = useForm<SignUpFormData>({
    resolver: zodResolver(signUpSchema),
    defaultValues: {
      fullName: "",
      email: "",
      password: "",
    },
  });

  const onSignIn = async (data: SignInFormData) => {
    const { error } = await signIn(data.email, data.password);
    
    if (error) {
      toast({
        title: "Erro ao entrar",
        description: error.message === "Invalid login credentials" 
          ? "E-mail ou senha incorretos" 
          : error.message,
        variant: "destructive",
      });
    } else {
      toast({
        title: "Login realizado com sucesso!",
        description: "Bem-vindo de volta.",
      });
      navigate("/");
    }
  };

  const onSignUp = async (data: SignUpFormData) => {
    const { error } = await signUp(data.email, data.password, data.fullName);
    
    if (error) {
      toast({
        title: "Erro ao criar conta",
        description: error.message === "User already registered" 
          ? "Este e-mail já está cadastrado" 
          : error.message,
        variant: "destructive",
      });
    } else {
      toast({
        title: "Conta criada com sucesso!",
        description: "Você já pode fazer login.",
      });
      setActiveTab("signin");
      signUpForm.reset();
    }
  };

  return (
    <div className="flex min-h-screen items-center justify-center bg-background p-4">
      <div className="w-full max-w-md space-y-8">
        <div className="flex flex-col items-center space-y-4">
          <Avatar className="h-16 w-16">
            <AvatarFallback className="bg-primary text-primary-foreground text-2xl">
              AC
            </AvatarFallback>
          </Avatar>
          <div className="text-center">
            <h1 className="text-3xl font-bold text-foreground">Acerto Certo</h1>
            <p className="text-muted-foreground">Sistema de Cobrança e Gerenciamento</p>
          </div>
        </div>

        <Card>
          <Tabs value={activeTab} onValueChange={setActiveTab}>
            <CardHeader>
              <TabsList className="grid w-full grid-cols-2">
                <TabsTrigger value="signin">Entrar</TabsTrigger>
                <TabsTrigger value="signup">Cadastrar</TabsTrigger>
              </TabsList>
            </CardHeader>

            <CardContent>
              <TabsContent value="signin">
                <form onSubmit={signInForm.handleSubmit(onSignIn)} className="space-y-4">
                  <div className="space-y-2">
                    <Label htmlFor="signin-email">E-mail</Label>
                    <Input
                      id="signin-email"
                      type="email"
                      placeholder="seu@email.com"
                      {...signInForm.register("email")}
                    />
                    {signInForm.formState.errors.email && (
                      <p className="text-sm text-destructive">
                        {signInForm.formState.errors.email.message}
                      </p>
                    )}
                  </div>

                  <div className="space-y-2">
                    <Label htmlFor="signin-password">Senha</Label>
                    <Input
                      id="signin-password"
                      type="password"
                      placeholder="••••••••"
                      {...signInForm.register("password")}
                    />
                    {signInForm.formState.errors.password && (
                      <p className="text-sm text-destructive">
                        {signInForm.formState.errors.password.message}
                      </p>
                    )}
                  </div>

                  <Button
                    type="submit"
                    className="w-full"
                    disabled={signInForm.formState.isSubmitting}
                  >
                    {signInForm.formState.isSubmitting ? "Entrando..." : "Entrar"}
                  </Button>
                </form>
              </TabsContent>

              <TabsContent value="signup">
                <form onSubmit={signUpForm.handleSubmit(onSignUp)} className="space-y-4">
                  <div className="space-y-2">
                    <Label htmlFor="signup-name">Nome</Label>
                    <Input
                      id="signup-name"
                      type="text"
                      placeholder="Seu nome completo"
                      {...signUpForm.register("fullName")}
                    />
                    {signUpForm.formState.errors.fullName && (
                      <p className="text-sm text-destructive">
                        {signUpForm.formState.errors.fullName.message}
                      </p>
                    )}
                  </div>

                  <div className="space-y-2">
                    <Label htmlFor="signup-email">E-mail</Label>
                    <Input
                      id="signup-email"
                      type="email"
                      placeholder="seu@email.com"
                      {...signUpForm.register("email")}
                    />
                    {signUpForm.formState.errors.email && (
                      <p className="text-sm text-destructive">
                        {signUpForm.formState.errors.email.message}
                      </p>
                    )}
                  </div>

                  <div className="space-y-2">
                    <Label htmlFor="signup-password">Senha</Label>
                    <Input
                      id="signup-password"
                      type="password"
                      placeholder="••••••••"
                      {...signUpForm.register("password")}
                    />
                    {signUpForm.formState.errors.password && (
                      <p className="text-sm text-destructive">
                        {signUpForm.formState.errors.password.message}
                      </p>
                    )}
                  </div>

                  <Button
                    type="submit"
                    className="w-full"
                    disabled={signUpForm.formState.isSubmitting}
                  >
                    {signUpForm.formState.isSubmitting ? "Criando conta..." : "Criar conta"}
                  </Button>
                </form>
              </TabsContent>
            </CardContent>
          </Tabs>
        </Card>
      </div>
    </div>
  );
}

--- Conteúdo de: src/pages/Configuracoes.tsx ---
import { AppHeader } from "@/components/AppHeader";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Button } from "@/components/ui/button";
import { Switch } from "@/components/ui/switch";
import { Separator } from "@/components/ui/separator";
import { toast } from "sonner";
import { useAuth } from "@/contexts/AuthContext";
import { supabase } from "@/integrations/supabase/client";
import { useEffect, useState } from "react";

export default function Configuracoes() {
  const { user } = useAuth();
  const [loading, setLoading] = useState(false);
  const [fullName, setFullName] = useState("");
  const [email, setEmail] = useState("");
  const [phone, setPhone] = useState("");
  const [cpf, setCpf] = useState("");
  const [pixKey, setPixKey] = useState("");

  useEffect(() => {
    loadProfile();
  }, [user]);

  const loadProfile = async () => {
    if (!user) return;
    
    try {
      const { data, error } = await supabase
        .from('profiles')
        .select('full_name, email, cpf, pix_key')
        .eq('user_id', user.id)
        .single();

      if (error) throw error;

      if (data) {
        setFullName(data.full_name || "");
        setEmail(data.email || "");
        setCpf(data.cpf || "");
        setPixKey(data.pix_key || "");
      }
    } catch (error) {
      console.error('Erro ao carregar perfil:', error);
      toast.error("Erro ao carregar suas informações");
    }
  };

  const handleSave = async () => {
    if (!user) {
      toast.error("Usuário não autenticado");
      return;
    }

    // Validação de CPF obrigatório
    if (!cpf || cpf.trim() === "") {
      toast.error("O campo CPF é obrigatório");
      return;
    }

    // Validação básica de formato CPF (somente números, 11 dígitos)
    const cpfNumeros = cpf.replace(/\D/g, '');
    if (cpfNumeros.length !== 11) {
      toast.error("CPF deve conter 11 dígitos");
      return;
    }

    setLoading(true);

    try {
      const { error } = await supabase
        .from('profiles')
        .update({
          full_name: fullName,
          email: email,
          cpf: cpfNumeros,
          pix_key: pixKey
        })
        .eq('user_id', user.id);

      if (error) throw error;

      toast.success("Configurações salvas com sucesso!");
    } catch (error) {
      console.error('Erro ao salvar:', error);
      toast.error("Erro ao salvar configurações");
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="flex flex-col min-h-screen">
      <AppHeader
        title="Configurações"
        subtitle="Gerencie as configurações da sua conta"
      />

      <main className="flex-1 p-6 max-w-4xl">
        <div className="space-y-6">
          <Card className="bg-card border-border">
            <CardHeader>
              <CardTitle className="text-foreground">Informações da Conta</CardTitle>
              <CardDescription className="text-muted-foreground">
                Atualize suas informações pessoais e de contato
              </CardDescription>
            </CardHeader>
            <CardContent className="space-y-4">
              <div className="grid gap-4 md:grid-cols-2">
                <div className="space-y-2">
                  <Label htmlFor="name" className="text-foreground">Nome</Label>
                  <Input
                    id="name"
                    value={fullName}
                    onChange={(e) => setFullName(e.target.value)}
                    placeholder="Seu nome completo"
                    className="bg-background border-input text-foreground"
                  />
                </div>
                <div className="space-y-2">
                  <Label htmlFor="email" className="text-foreground">E-mail</Label>
                  <Input
                    id="email"
                    type="email"
                    value={email}
                    onChange={(e) => setEmail(e.target.value)}
                    placeholder="seu@email.com"
                    className="bg-background border-input text-foreground"
                  />
                </div>
              </div>
              <div className="space-y-2">
                <Label htmlFor="phone" className="text-foreground">Telefone</Label>
                <Input
                  id="phone"
                  value={phone}
                  onChange={(e) => setPhone(e.target.value)}
                  placeholder="(11) 1234-5678"
                  className="bg-background border-input text-foreground"
                />
              </div>
              <div className="grid gap-4 md:grid-cols-2">
                <div className="space-y-2">
                  <Label htmlFor="cpf" className="text-foreground">
                    CPF <span className="text-destructive">*</span>
                  </Label>
                  <Input
                    id="cpf"
                    value={cpf}
                    onChange={(e) => setCpf(e.target.value)}
                    placeholder="Somente números"
                    maxLength={14}
                    className="bg-background border-input text-foreground"
                  />
                </div>
                <div className="space-y-2">
                  <Label htmlFor="pix_key" className="text-foreground">Chave PIX</Label>
                  <Input
                    id="pix_key"
                    value={pixKey}
                    onChange={(e) => setPixKey(e.target.value)}
                    placeholder="Sua Chave PIX"
                    className="bg-background border-input text-foreground"
                  />
                </div>
              </div>
              <Button 
                onClick={handleSave} 
                disabled={loading}
                className="bg-primary hover:bg-primary/90 text-primary-foreground"
              >
                {loading ? "Salvando..." : "Salvar Alterações"}
              </Button>
            </CardContent>
          </Card>

          <Card className="bg-card border-border">
            <CardHeader>
              <CardTitle className="text-foreground">Notificações</CardTitle>
              <CardDescription className="text-muted-foreground">
                Configure como deseja receber notificações
              </CardDescription>
            </CardHeader>
            <CardContent className="space-y-4">
              <div className="flex items-center justify-between">
                <div className="space-y-0.5">
                  <Label className="text-foreground">Novos Clientes</Label>
                  <p className="text-sm text-muted-foreground">
                    Receber notificação quando um novo cliente for cadastrado
                  </p>
                </div>
                <Switch defaultChecked />
              </div>
              <Separator className="bg-border" />
              <div className="flex items-center justify-between">
                <div className="space-y-0.5">
                  <Label className="text-foreground">Pagamentos</Label>
                  <p className="text-sm text-muted-foreground">
                    Receber notificação sobre pagamentos recebidos
                  </p>
                </div>
                <Switch defaultChecked />
              </div>
              <Separator className="bg-border" />
              <div className="flex items-center justify-between">
                <div className="space-y-0.5">
                  <Label className="text-foreground">Relatórios</Label>
                  <p className="text-sm text-muted-foreground">
                    Receber relatórios semanais por e-mail
                  </p>
                </div>
                <Switch />
              </div>
            </CardContent>
          </Card>

          <Card className="bg-card border-border border-destructive/50">
            <CardHeader>
              <CardTitle className="text-destructive">Zona de Perigo</CardTitle>
              <CardDescription className="text-muted-foreground">
                Ações irreversíveis para sua conta
              </CardDescription>
            </CardHeader>
            <CardContent>
              <Button variant="destructive" className="bg-destructive hover:bg-destructive/90 text-destructive-foreground">
                Excluir Conta
              </Button>
            </CardContent>
          </Card>
        </div>
      </main>
    </div>
  );
}

--- Conteúdo de: src/pages/Dashboard.tsx ---
import { AppHeader } from "@/components/AppHeader";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Users, DollarSign, TrendingUp, UserCheck } from "lucide-react";

const statsCards = [
  {
    title: "Clientes Ativos",
    value: "127",
    change: "+12%",
    icon: Users,
    trend: "up",
  },
  {
    title: "Receita Mensal",
    value: "R$ 45.890",
    change: "+8.3%",
    icon: DollarSign,
    trend: "up",
  },
  {
    title: "Taxa de Conversão",
    value: "68%",
    change: "+5.2%",
    icon: TrendingUp,
    trend: "up",
  },
  {
    title: "Novos Clientes",
    value: "23",
    change: "+15%",
    icon: UserCheck,
    trend: "up",
  },
];

const recentClients = [
  { name: "João Silva", email: "joao@email.com", plan: "Premium", status: "Ativo" },
  { name: "Maria Santos", email: "maria@email.com", plan: "Básico", status: "Ativo" },
  { name: "Pedro Costa", email: "pedro@email.com", plan: "Premium", status: "Ativo" },
  { name: "Ana Lima", email: "ana@email.com", plan: "Intermediário", status: "Pendente" },
];

export default function Dashboard() {
  return (
    <div className="flex flex-col min-h-screen">
      <AppHeader 
        title="Dashboard" 
        subtitle="Visão geral do seu painel de revendas"
      />
      
      <main className="flex-1 p-6 space-y-6">
        <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-4">
          {statsCards.map((stat) => {
            const Icon = stat.icon;
            return (
              <Card key={stat.title} className="bg-card border-border">
                <CardHeader className="flex flex-row items-center justify-between pb-2">
                  <CardTitle className="text-sm font-medium text-muted-foreground">
                    {stat.title}
                  </CardTitle>
                  <Icon className="h-4 w-4 text-primary" />
                </CardHeader>
                <CardContent>
                  <div className="text-2xl font-bold text-foreground">{stat.value}</div>
                  <p className="text-xs text-success flex items-center gap-1 mt-1">
                    <TrendingUp className="h-3 w-3" />
                    {stat.change} em relação ao mês anterior
                  </p>
                </CardContent>
              </Card>
            );
          })}
        </div>

        <div className="grid gap-4 md:grid-cols-2">
          <Card className="bg-card border-border">
            <CardHeader>
              <CardTitle className="text-foreground">Clientes Recentes</CardTitle>
            </CardHeader>
            <CardContent>
              <div className="space-y-4">
                {recentClients.map((client, idx) => (
                  <div
                    key={idx}
                    className="flex items-center justify-between p-3 rounded-lg bg-background border border-border"
                  >
                    <div className="flex items-center gap-3">
                      <div className="h-10 w-10 rounded-full bg-primary/10 flex items-center justify-center">
                        <span className="text-sm font-medium text-primary">
                          {client.name.charAt(0)}
                        </span>
                      </div>
                      <div>
                        <p className="text-sm font-medium text-foreground">{client.name}</p>
                        <p className="text-xs text-muted-foreground">{client.email}</p>
                      </div>
                    </div>
                    <div className="text-right">
                      <p className="text-sm font-medium text-foreground">{client.plan}</p>
                      <span
                        className={`text-xs px-2 py-1 rounded-full ${
                          client.status === "Ativo"
                            ? "bg-success/10 text-success"
                            : "bg-warning/10 text-warning"
                        }`}
                      >
                        {client.status}
                      </span>
                    </div>
                  </div>
                ))}
              </div>
            </CardContent>
          </Card>

          <Card className="bg-card border-border">
            <CardHeader>
              <CardTitle className="text-foreground">Resumo de Vendas</CardTitle>
            </CardHeader>
            <CardContent>
              <div className="space-y-4">
                <div className="flex items-center justify-between p-4 rounded-lg bg-background border border-border">
                  <div>
                    <p className="text-sm font-medium text-muted-foreground">Plano Básico</p>
                    <p className="text-2xl font-bold text-foreground">45</p>
                  </div>
                  <div className="text-right">
                    <p className="text-sm text-muted-foreground">R$ 12.450</p>
                    <p className="text-xs text-success">+8%</p>
                  </div>
                </div>
                <div className="flex items-center justify-between p-4 rounded-lg bg-background border border-border">
                  <div>
                    <p className="text-sm font-medium text-muted-foreground">Plano Intermediário</p>
                    <p className="text-2xl font-bold text-foreground">52</p>
                  </div>
                  <div className="text-right">
                    <p className="text-sm text-muted-foreground">R$ 18.240</p>
                    <p className="text-xs text-success">+12%</p>
                  </div>
                </div>
                <div className="flex items-center justify-between p-4 rounded-lg bg-background border border-border">
                  <div>
                    <p className="text-sm font-medium text-muted-foreground">Plano Premium</p>
                    <p className="text-2xl font-bold text-foreground">30</p>
                  </div>
                  <div className="text-right">
                    <p className="text-sm text-muted-foreground">R$ 15.200</p>
                    <p className="text-xs text-success">+5%</p>
                  </div>
                </div>
              </div>
            </CardContent>
          </Card>
        </div>
      </main>
    </div>
  );
}

--- Conteúdo de: src/pages/Index.tsx ---
// Update this page (the content is just a fallback if you fail to update the page)

const Index = () => {
  return (
    <div className="flex min-h-screen items-center justify-center bg-background">
      <div className="text-center">
        <h1 className="mb-4 text-4xl font-bold">Welcome to Your Blank App</h1>
        <p className="text-xl text-muted-foreground">Start building your amazing project here!</p>
      </div>
    </div>
  );
};

export default Index;

--- Conteúdo de: src/pages/NotFound.tsx ---
import { useLocation } from "react-router-dom";
import { useEffect } from "react";

const NotFound = () => {
  const location = useLocation();

  useEffect(() => {
    console.error("404 Error: User attempted to access non-existent route:", location.pathname);
  }, [location.pathname]);

  return (
    <div className="flex min-h-screen items-center justify-center bg-gray-100">
      <div className="text-center">
        <h1 className="mb-4 text-4xl font-bold">404</h1>
        <p className="mb-4 text-xl text-gray-600">Oops! Page not found</p>
        <a href="/" className="text-blue-500 underline hover:text-blue-700">
          Return to Home
        </a>
      </div>
    </div>
  );
};

export default NotFound;

--- Conteúdo de: src/pages/Planos.tsx ---
import { useState, useEffect } from "react";
import { Plus, Edit, Trash2 } from "lucide-react";
import { AppHeader } from "@/components/AppHeader";
import { Button } from "@/components/ui/button";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { useToast } from "@/hooks/use-toast";
import { supabase } from "@/integrations/supabase/client";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import * as z from "zod";

const planoSchema = z.object({
  nome: z.string().min(3, "Nome deve ter no mínimo 3 caracteres"),
  valor: z.string().refine((val) => !isNaN(Number(val)) && Number(val) >= 0, {
    message: "Valor deve ser um número positivo",
  }),
});

type PlanoFormData = z.infer<typeof planoSchema>;

interface Plano {
  id: string;
  nome: string;
  valor: number;
  created_at: string;
}

export default function Planos() {
  const [planos, setPlanos] = useState<Plano[]>([]);
  const [loading, setLoading] = useState(true);
  const [dialogOpen, setDialogOpen] = useState(false);
  const [editDialogOpen, setEditDialogOpen] = useState(false);
  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);
  const [submitting, setSubmitting] = useState(false);
  const [selectedPlano, setSelectedPlano] = useState<Plano | null>(null);
  const { toast } = useToast();

  const form = useForm<PlanoFormData>({
    resolver: zodResolver(planoSchema),
    defaultValues: {
      nome: "",
      valor: "0",
    },
  });

  const editForm = useForm<PlanoFormData>({
    resolver: zodResolver(planoSchema),
    defaultValues: {
      nome: "",
      valor: "0",
    },
  });

  const loadPlanos = async () => {
    try {
      setLoading(true);
      
      const { data, error } = await supabase
        .from("planos")
        .select("*")
        .order("created_at", { ascending: false });

      if (error) throw error;

      setPlanos(data || []);
    } catch (error: any) {
      console.error("Error loading planos:", error);
      toast({
        title: "Erro ao carregar planos",
        description: error.message,
        variant: "destructive",
      });
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    loadPlanos();
  }, []);

  const onSubmit = async (data: PlanoFormData) => {
    try {
      setSubmitting(true);

      const { error } = await supabase
        .from("planos")
        .insert({
          nome: data.nome,
          valor: Number(data.valor),
        });

      if (error) throw error;

      toast({
        title: "Plano criado com sucesso!",
        description: `${data.nome} foi adicionado ao sistema.`,
      });

      setDialogOpen(false);
      form.reset();
      loadPlanos();
    } catch (error: any) {
      console.error("Error creating plano:", error);
      
      let errorMessage = "Ocorreu um erro ao criar o plano";
      
      if (error.message?.includes("duplicate key")) {
        errorMessage = "Já existe um plano com este nome";
      } else if (error.message) {
        errorMessage = error.message;
      }
      
      toast({
        title: "Erro ao criar plano",
        description: errorMessage,
        variant: "destructive",
      });
    } finally {
      setSubmitting(false);
    }
  };

  const onEdit = async (data: PlanoFormData) => {
    if (!selectedPlano) return;

    try {
      setSubmitting(true);

      const { error } = await supabase
        .from("planos")
        .update({
          nome: data.nome,
          valor: Number(data.valor),
        })
        .eq("id", selectedPlano.id);

      if (error) throw error;

      toast({
        title: "Plano atualizado com sucesso!",
        description: `${data.nome} foi atualizado.`,
      });

      setEditDialogOpen(false);
      editForm.reset();
      loadPlanos();
    } catch (error: any) {
      console.error("Error updating plano:", error);
      
      let errorMessage = "Ocorreu um erro ao atualizar o plano";
      
      if (error.message?.includes("duplicate key")) {
        errorMessage = "Já existe um plano com este nome";
      } else if (error.message) {
        errorMessage = error.message;
      }
      
      toast({
        title: "Erro ao atualizar plano",
        description: errorMessage,
        variant: "destructive",
      });
    } finally {
      setSubmitting(false);
    }
  };

  const onDelete = async () => {
    if (!selectedPlano) return;

    try {
      setSubmitting(true);

      const { error } = await supabase
        .from("planos")
        .delete()
        .eq("id", selectedPlano.id);

      if (error) throw error;

      toast({
        title: "Plano excluído com sucesso!",
        description: `${selectedPlano.nome} foi removido do sistema.`,
      });

      setDeleteDialogOpen(false);
      setSelectedPlano(null);
      loadPlanos();
    } catch (error: any) {
      console.error("Error deleting plano:", error);
      toast({
        title: "Erro ao excluir plano",
        description: error.message || "Ocorreu um erro ao excluir o plano",
        variant: "destructive",
      });
    } finally {
      setSubmitting(false);
    }
  };

  const handleEdit = (plano: Plano) => {
    setSelectedPlano(plano);
    editForm.reset({
      nome: plano.nome,
      valor: plano.valor.toString(),
    });
    setEditDialogOpen(true);
  };

  const handleDelete = (plano: Plano) => {
    setSelectedPlano(plano);
    setDeleteDialogOpen(true);
  };

  const formatCurrency = (value: number) => {
    return new Intl.NumberFormat("pt-BR", {
      style: "currency",
      currency: "BRL",
    }).format(value);
  };

  return (
    <div className="min-h-screen bg-background">
      <AppHeader 
        title="Planos e Preços" 
        subtitle="Gerencie os planos disponíveis para seus clientes"
      />

      <main className="container mx-auto p-6">
        <div className="mb-6 flex justify-between items-center">
          <div>
            <h2 className="text-2xl font-bold text-foreground">Planos</h2>
            <p className="text-muted-foreground">
              Gerencie os planos do sistema
            </p>
          </div>
          <Button onClick={() => setDialogOpen(true)}>
            <Plus className="mr-2 h-4 w-4" />
            Novo Plano
          </Button>
        </div>

        <div className="rounded-lg border bg-card">
          <Table>
            <TableHeader>
              <TableRow>
                <TableHead>Nome</TableHead>
                <TableHead>Valor</TableHead>
                <TableHead className="text-right">Ações</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {loading ? (
                <TableRow>
                  <TableCell colSpan={3} className="text-center py-8">
                    <div className="flex justify-center">
                      <div className="h-8 w-8 animate-spin rounded-full border-4 border-primary border-t-transparent"></div>
                    </div>
                  </TableCell>
                </TableRow>
              ) : planos.length === 0 ? (
                <TableRow>
                  <TableCell colSpan={3} className="text-center py-8 text-muted-foreground">
                    Nenhum plano encontrado
                  </TableCell>
                </TableRow>
              ) : (
                planos.map((plano) => (
                  <TableRow key={plano.id}>
                    <TableCell className="font-medium">
                      {plano.nome}
                    </TableCell>
                    <TableCell>{formatCurrency(plano.valor)}</TableCell>
                    <TableCell className="text-right">
                      <div className="flex justify-end gap-2">
                        <Button 
                          variant="ghost" 
                          size="icon"
                          onClick={() => handleEdit(plano)}
                        >
                          <Edit className="h-4 w-4" />
                        </Button>
                        <Button 
                          variant="ghost" 
                          size="icon"
                          onClick={() => handleDelete(plano)}
                        >
                          <Trash2 className="h-4 w-4 text-destructive" />
                        </Button>
                      </div>
                    </TableCell>
                  </TableRow>
                ))
              )}
            </TableBody>
          </Table>
        </div>
      </main>

      {/* Create Dialog */}
      <Dialog open={dialogOpen} onOpenChange={setDialogOpen}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Novo Plano</DialogTitle>
            <DialogDescription>
              Crie um novo plano no sistema
            </DialogDescription>
          </DialogHeader>

          <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
            <div className="space-y-2">
              <Label htmlFor="nome">Nome do Plano</Label>
              <Input
                id="nome"
                {...form.register("nome")}
                placeholder="Ex: Básico, Intermediário, Premium"
              />
              {form.formState.errors.nome && (
                <p className="text-sm text-destructive">
                  {form.formState.errors.nome.message}
                </p>
              )}
            </div>

            <div className="space-y-2">
              <Label htmlFor="valor">Valor (R$)</Label>
              <Input
                id="valor"
                type="number"
                step="0.01"
                {...form.register("valor")}
                placeholder="0.00"
              />
              {form.formState.errors.valor && (
                <p className="text-sm text-destructive">
                  {form.formState.errors.valor.message}
                </p>
              )}
            </div>

            <DialogFooter>
              <Button
                type="button"
                variant="outline"
                onClick={() => setDialogOpen(false)}
                disabled={submitting}
              >
                Cancelar
              </Button>
              <Button type="submit" disabled={submitting}>
                {submitting ? "Criando..." : "Criar Plano"}
              </Button>
            </DialogFooter>
          </form>
        </DialogContent>
      </Dialog>

      {/* Edit Dialog */}
      <Dialog open={editDialogOpen} onOpenChange={setEditDialogOpen}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Editar Plano</DialogTitle>
            <DialogDescription>
              Atualize as informações do plano
            </DialogDescription>
          </DialogHeader>

          <form onSubmit={editForm.handleSubmit(onEdit)} className="space-y-4">
            <div className="space-y-2">
              <Label htmlFor="edit-nome">Nome do Plano</Label>
              <Input
                id="edit-nome"
                {...editForm.register("nome")}
                placeholder="Ex: Básico, Intermediário, Premium"
              />
              {editForm.formState.errors.nome && (
                <p className="text-sm text-destructive">
                  {editForm.formState.errors.nome.message}
                </p>
              )}
            </div>

            <div className="space-y-2">
              <Label htmlFor="edit-valor">Valor (R$)</Label>
              <Input
                id="edit-valor"
                type="number"
                step="0.01"
                {...editForm.register("valor")}
                placeholder="0.00"
              />
              {editForm.formState.errors.valor && (
                <p className="text-sm text-destructive">
                  {editForm.formState.errors.valor.message}
                </p>
              )}
            </div>

            <DialogFooter>
              <Button
                type="button"
                variant="outline"
                onClick={() => setEditDialogOpen(false)}
                disabled={submitting}
              >
                Cancelar
              </Button>
              <Button type="submit" disabled={submitting}>
                {submitting ? "Salvando..." : "Salvar"}
              </Button>
            </DialogFooter>
          </form>
        </DialogContent>
      </Dialog>

      {/* Delete Dialog */}
      <AlertDialog open={deleteDialogOpen} onOpenChange={setDeleteDialogOpen}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Confirmar Exclusão</AlertDialogTitle>
            <AlertDialogDescription>
              Tem certeza que deseja excluir o plano "{selectedPlano?.nome}"?
              Esta ação não pode ser desfeita. Os revendedores que possuem este
              plano terão o campo de plano definido como vazio.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel disabled={submitting}>Cancelar</AlertDialogCancel>
            <AlertDialogAction
              onClick={onDelete}
              disabled={submitting}
              className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
            >
              {submitting ? "Excluindo..." : "Excluir"}
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </div>
  );
}

--- Conteúdo de: src/pages/Revenda.tsx ---
import { useState, useEffect } from "react";
import { Plus, Trash2, Edit, MoreVertical, Bell } from "lucide-react";
import { AppHeader } from "@/components/AppHeader";
import { Button } from "@/components/ui/button";
import { NotificationDialog } from "@/components/NotificationDialog";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { Badge } from "@/components/ui/badge";
import { useToast } from "@/hooks/use-toast";
import { supabase } from "@/integrations/supabase/client";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import * as z from "zod";

const resellerSchema = z.object({
  fullName: z.string().min(3, "Nome deve ter no mínimo 3 caracteres"),
  email: z.string().email("E-mail inválido"),
  password: z.string().min(6, "A senha deve ter no mínimo 6 caracteres"),
  resellerRole: z.enum(["master", "reseller"], {
    required_error: "Selecione um nível",
  }),
});

const editResellerSchema = z.object({
  fullName: z.string().min(3, "Nome deve ter no mínimo 3 caracteres"),
  email: z.string().email("E-mail inválido"),
  phone: z.string().min(10, "Telefone inválido"),
  password: z.string().optional(),
  planId: z.string().optional(),
  expiryDate: z.string().optional(),
  status: z.enum(["active", "inactive", "suspended"]).optional(),
});

type ResellerFormData = z.infer<typeof resellerSchema>;
type EditResellerFormData = z.infer<typeof editResellerSchema>;

interface Plano {
  id: string;
  nome: string;
  valor: number;
}

interface ResellerProfile {
  id: string;
  user_id: string;
  full_name: string;
  email: string;
  phone: string;
  created_at: string;
  created_by: string;
  plan_id: string | null;
  expiry_date: string | null;
  status: string;
  planos?: Plano | null;
}

interface ResellerRole {
  role: string;
}

interface ResellerWithRole extends ResellerProfile {
  role: string;
}

export default function Revenda() {
  const [resellers, setResellers] = useState<ResellerWithRole[]>([]);
  const [planos, setPlanos] = useState<Plano[]>([]);
  const [loading, setLoading] = useState(true);
  const [dialogOpen, setDialogOpen] = useState(false);
  const [editDialogOpen, setEditDialogOpen] = useState(false);
  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);
  const [notificationDialogOpen, setNotificationDialogOpen] = useState(false);
  const [submitting, setSubmitting] = useState(false);
  const [selectedReseller, setSelectedReseller] = useState<ResellerWithRole | null>(null);
  const [selectedPlanValue, setSelectedPlanValue] = useState<number>(0);
  const { toast } = useToast();

  const form = useForm<ResellerFormData>({
    resolver: zodResolver(resellerSchema),
    defaultValues: {
      fullName: "",
      email: "",
      password: "",
      resellerRole: "reseller",
    },
  });

  const editForm = useForm<EditResellerFormData>({
    resolver: zodResolver(editResellerSchema),
    defaultValues: {
      fullName: "",
      email: "",
      phone: "",
      password: "",
      planId: "",
      expiryDate: "",
      status: "active",
    },
  });

  const loadPlanos = async () => {
    try {
      const { data, error } = await supabase
        .from("planos")
        .select("*")
        .order("nome", { ascending: true });

      if (error) throw error;
      setPlanos(data || []);
    } catch (error: any) {
      console.error("Error loading planos:", error);
      toast({
        title: "Erro ao carregar planos",
        description: error.message,
        variant: "destructive",
      });
    }
  };

  const loadResellers = async () => {
    try {
      setLoading(true);
      
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) throw new Error("Usuário não autenticado");

      const { data: profiles, error: profilesError } = await supabase
        .from("profiles")
        .select("*, planos(id, nome, valor)")
        .eq("created_by", user.id)
        .order("created_at", { ascending: false });

      if (profilesError) throw profilesError;

      const resellersWithRoles: ResellerWithRole[] = [];
      
      for (const profile of profiles || []) {
        const { data: roleData } = await supabase
          .from("user_roles")
          .select("role")
          .eq("user_id", profile.user_id)
          .maybeSingle();
        
        resellersWithRoles.push({
          ...profile,
          role: roleData?.role || "reseller",
        });
      }

      setResellers(resellersWithRoles);
    } catch (error: any) {
      console.error("Error loading resellers:", error);
      toast({
        title: "Erro ao carregar revendedores",
        description: error.message,
        variant: "destructive",
      });
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    loadPlanos();
    loadResellers();
  }, []);

  const onSubmit = async (data: ResellerFormData) => {
    try {
      setSubmitting(true);

      const { data: sessionData } = await supabase.auth.getSession();
      
      if (!sessionData.session) {
        throw new Error("Não autenticado");
      }

      const { data: result, error } = await supabase.functions.invoke(
        "create-reseller-user",
        {
          body: {
            email: data.email,
            password: data.password,
            fullName: data.fullName,
            resellerRole: data.resellerRole,
          },
        }
      );

      if (error) throw error;

      if (result?.error) {
        throw new Error(result.error);
      }

      toast({
        title: "Revendedor criado com sucesso!",
        description: `${data.fullName} foi adicionado ao sistema.`,
      });

      setDialogOpen(false);
      form.reset();
      loadResellers();
    } catch (error: any) {
      console.error("Error creating reseller:", error);
      
      let errorMessage = "Ocorreu um erro ao criar o revendedor";
      
      if (error.message?.includes("already been registered") || 
          error.message?.includes("email_exists")) {
        errorMessage = "Este e-mail já está cadastrado no sistema";
      } else if (error.message?.includes("Only master users")) {
        errorMessage = "Apenas usuários master podem Criar Usuários";
      } else if (error.message) {
        errorMessage = error.message;
      }
      
      toast({
        title: "Erro ao Criar Usuário",
        description: errorMessage,
        variant: "destructive",
      });
    } finally {
      setSubmitting(false);
    }
  };

  const onEdit = async (data: EditResellerFormData) => {
    if (!selectedReseller) return;

    try {
      setSubmitting(true);

      const { data: sessionData } = await supabase.auth.getSession();
      
      if (!sessionData.session) {
        throw new Error("Não autenticado");
      }

      const { data: result, error } = await supabase.functions.invoke(
        "update-reseller-user",
        {
          body: {
            userId: selectedReseller.user_id,
            email: data.email,
            fullName: data.fullName,
            phone: data.phone,
            password: data.password || undefined,
            planId: data.planId || undefined,
            expiryDate: data.expiryDate || undefined,
            status: data.status,
          },
        }
      );

      if (error) throw error;

      if (result?.error) {
        throw new Error(result.error);
      }

      toast({
        title: "Revendedor atualizado com sucesso!",
        description: `${data.fullName} foi atualizado.`,
      });

      setEditDialogOpen(false);
      editForm.reset();
      loadResellers();
    } catch (error: any) {
      console.error("Error updating reseller:", error);
      toast({
        title: "Erro ao atualizar revendedor",
        description: error.message || "Ocorreu um erro ao atualizar o revendedor",
        variant: "destructive",
      });
    } finally {
      setSubmitting(false);
    }
  };

  const onDelete = async () => {
    if (!selectedReseller) return;

    try {
      setSubmitting(true);

      const { data: sessionData } = await supabase.auth.getSession();
      
      if (!sessionData.session) {
        throw new Error("Não autenticado");
      }

      const { data: result, error } = await supabase.functions.invoke(
        "delete-reseller-user",
        {
          body: {
            userId: selectedReseller.user_id,
          },
        }
      );

      if (error) throw error;

      if (result?.error) {
        throw new Error(result.error);
      }

      toast({
        title: "Revendedor excluído com sucesso!",
        description: `${selectedReseller.full_name} foi removido do sistema.`,
      });

      setDeleteDialogOpen(false);
      setSelectedReseller(null);
      loadResellers();
    } catch (error: any) {
      console.error("Error deleting reseller:", error);
      toast({
        title: "Erro ao excluir revendedor",
        description: error.message || "Ocorreu um erro ao excluir o revendedor",
        variant: "destructive",
      });
    } finally {
      setSubmitting(false);
    }
  };

  const handleEdit = (reseller: ResellerWithRole) => {
    setSelectedReseller(reseller);
    editForm.reset({
      fullName: reseller.full_name,
      email: reseller.email,
      phone: reseller.phone || "",
      password: "",
      planId: reseller.plan_id || "",
      expiryDate: reseller.expiry_date ? new Date(reseller.expiry_date).toISOString().split('T')[0] : "",
      status: (reseller.status as "active" | "inactive" | "suspended") || "active",
    });
    if (reseller.planos) {
      setSelectedPlanValue(reseller.planos.valor);
    } else {
      setSelectedPlanValue(0);
    }
    setEditDialogOpen(true);
  };

  const handleDelete = (reseller: ResellerWithRole) => {
    setSelectedReseller(reseller);
    setDeleteDialogOpen(true);
  };

  const getStatusBadge = (status: string) => {
    const variants: Record<string, "default" | "secondary" | "destructive"> = {
      active: "default",
      inactive: "secondary",
      suspended: "destructive",
    };
    
    const labels: Record<string, string> = {
      active: "Ativo",
      inactive: "Inativo",
      suspended: "Suspenso",
    };

    return (
      <Badge variant={variants[status] || "secondary"}>
        {labels[status] || status}
      </Badge>
    );
  };

  const formatCurrency = (value: number) => {
    return new Intl.NumberFormat("pt-BR", {
      style: "currency",
      currency: "BRL",
    }).format(value);
  };

  return (
    <div className="min-h-screen bg-background">
      <AppHeader title="Gerenciar Revendedores" />

      <main className="container mx-auto p-6">
        <div className="mb-6 flex justify-between items-center">
          <div>
            <h2 className="text-2xl font-bold text-foreground">Revendedores</h2>
            <p className="text-muted-foreground">
              Gerencie os revendedores do sistema
            </p>
          </div>
          <Button onClick={() => setDialogOpen(true)}>
            <Plus className="mr-2 h-4 w-4" />
            Novo Revendedor
          </Button>
        </div>

        <div className="rounded-lg border bg-card">
          <Table>
            <TableHeader>
              <TableRow>
                <TableHead>Nome</TableHead>
                <TableHead>E-mail</TableHead>
                <TableHead>Telefone</TableHead>
                <TableHead>Nível</TableHead>
                <TableHead>Plano</TableHead>
                <TableHead>Valor</TableHead>
                <TableHead>Vencimento</TableHead>
                <TableHead>Status</TableHead>
                <TableHead className="text-right">Ações</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {loading ? (
                <TableRow>
                  <TableCell colSpan={9} className="text-center py-8">
                    <div className="flex justify-center">
                      <div className="h-8 w-8 animate-spin rounded-full border-4 border-primary border-t-transparent"></div>
                    </div>
                  </TableCell>
                </TableRow>
              ) : resellers.length === 0 ? (
                <TableRow>
                  <TableCell colSpan={9} className="text-center py-8 text-muted-foreground">
                    Nenhum revendedor encontrado
                  </TableCell>
                </TableRow>
              ) : (
                resellers.map((reseller) => (
                  <TableRow key={reseller.id}>
                    <TableCell className="font-medium">
                      {reseller.full_name || "N/A"}
                    </TableCell>
                    <TableCell>{reseller.email || "N/A"}</TableCell>
                    <TableCell>{reseller.phone || "N/A"}</TableCell>
                    <TableCell>
                      <Badge
                        variant={
                          reseller.role === "master"
                            ? "default"
                            : "secondary"
                        }
                      >
                        {reseller.role === "master"
                          ? "Master"
                          : "Revendedor"}
                      </Badge>
                    </TableCell>
                    <TableCell>{reseller.planos?.nome || "N/A"}</TableCell>
                    <TableCell>
                      {reseller.planos?.valor 
                        ? formatCurrency(reseller.planos.valor)
                        : "N/A"}
                    </TableCell>
                    <TableCell>
                      {reseller.expiry_date 
                        ? new Date(reseller.expiry_date).toLocaleDateString("pt-BR")
                        : "N/A"}
                    </TableCell>
                    <TableCell>{getStatusBadge(reseller.status)}</TableCell>
                    <TableCell className="text-right">
                      <DropdownMenu>
                        <DropdownMenuTrigger asChild>
                          <Button variant="ghost" size="icon">
                            <MoreVertical className="h-4 w-4" />
                          </Button>
                        </DropdownMenuTrigger>
                        <DropdownMenuContent align="end">
                          <DropdownMenuItem onClick={() => handleEdit(reseller)}>
                            <Edit className="mr-2 h-4 w-4" />
                            Editar
                          </DropdownMenuItem>
                          <DropdownMenuItem 
                            className="text-destructive"
                            onClick={() => handleDelete(reseller)}
                          >
                            <Trash2 className="mr-2 h-4 w-4" />
                            Excluir
                          </DropdownMenuItem>
                          <DropdownMenuSeparator />
                          <DropdownMenuItem onClick={() => {
                            setSelectedReseller(reseller);
                            setNotificationDialogOpen(true);
                          }}>
                            <Bell className="mr-2 h-4 w-4" />
                            Notificar
                          </DropdownMenuItem>
                        </DropdownMenuContent>
                      </DropdownMenu>
                    </TableCell>
                  </TableRow>
                ))
              )}
            </TableBody>
          </Table>
        </div>
      </main>

      {/* Create Dialog */}
      <Dialog open={dialogOpen} onOpenChange={setDialogOpen}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Novo Revendedor</DialogTitle>
            <DialogDescription>
              Crie um novo usuário revendedor no sistema
            </DialogDescription>
          </DialogHeader>

          <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
            <div className="space-y-2">
              <Label htmlFor="fullName">Nome Completo</Label>
              <Input
                id="fullName"
                {...form.register("fullName")}
                placeholder="João Silva"
              />
              {form.formState.errors.fullName && (
                <p className="text-sm text-destructive">
                  {form.formState.errors.fullName.message}
                </p>
              )}
            </div>

            <div className="space-y-2">
              <Label htmlFor="email">E-mail</Label>
              <Input
                id="email"
                type="email"
                {...form.register("email")}
                placeholder="joao@exemplo.com"
              />
              {form.formState.errors.email && (
                <p className="text-sm text-destructive">
                  {form.formState.errors.email.message}
                </p>
              )}
            </div>

            <div className="space-y-2">
              <Label htmlFor="password">Senha</Label>
              <Input
                id="password"
                type="password"
                {...form.register("password")}
                placeholder="••••••••"
              />
              {form.formState.errors.password && (
                <p className="text-sm text-destructive">
                  {form.formState.errors.password.message}
                </p>
              )}
            </div>

            <div className="space-y-2">
              <Label htmlFor="resellerRole">Nível</Label>
              <Select
                onValueChange={(value) =>
                  form.setValue("resellerRole", value as "master" | "reseller")
                }
                defaultValue="reseller"
              >
                <SelectTrigger>
                  <SelectValue placeholder="Selecione o nível" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="master">Revenda Master</SelectItem>
                  <SelectItem value="reseller">Revenda</SelectItem>
                </SelectContent>
              </Select>
              {form.formState.errors.resellerRole && (
                <p className="text-sm text-destructive">
                  {form.formState.errors.resellerRole.message}
                </p>
              )}
            </div>

            <DialogFooter>
              <Button
                type="button"
                variant="outline"
                onClick={() => setDialogOpen(false)}
                disabled={submitting}
              >
                Cancelar
              </Button>
              <Button type="submit" disabled={submitting}>
                {submitting ? "Criando..." : "Criar Usuário"}
              </Button>
            </DialogFooter>
          </form>
        </DialogContent>
      </Dialog>

      {/* Edit Dialog */}
      <Dialog open={editDialogOpen} onOpenChange={setEditDialogOpen}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Editar Revendedor</DialogTitle>
            <DialogDescription>
              Atualize as informações do revendedor
            </DialogDescription>
          </DialogHeader>

          <form onSubmit={editForm.handleSubmit(onEdit)} className="space-y-4">
            <div className="space-y-2">
              <Label htmlFor="edit-fullName">Nome Completo</Label>
              <Input
                id="edit-fullName"
                {...editForm.register("fullName")}
                placeholder="João Silva"
              />
              {editForm.formState.errors.fullName && (
                <p className="text-sm text-destructive">
                  {editForm.formState.errors.fullName.message}
                </p>
              )}
            </div>

            <div className="space-y-2">
              <Label htmlFor="edit-email">E-mail</Label>
              <Input
                id="edit-email"
                type="email"
                {...editForm.register("email")}
                placeholder="joao@exemplo.com"
              />
              {editForm.formState.errors.email && (
                <p className="text-sm text-destructive">
                  {editForm.formState.errors.email.message}
                </p>
              )}
            </div>

            <div className="space-y-2">
              <Label htmlFor="edit-phone">Telefone *</Label>
              <Input
                id="edit-phone"
                type="tel"
                {...editForm.register("phone")}
                placeholder="(XX) XXXXX-XXXX"
              />
              {editForm.formState.errors.phone && (
                <p className="text-sm text-destructive">
                  {editForm.formState.errors.phone.message}
                </p>
              )}
            </div>

            <div className="space-y-2">
              <Label htmlFor="edit-password">Nova Senha (opcional)</Label>
              <Input
                id="edit-password"
                type="password"
                {...editForm.register("password")}
                placeholder="••••••••"
              />
              {editForm.formState.errors.password && (
                <p className="text-sm text-destructive">
                  {editForm.formState.errors.password.message}
                </p>
              )}
            </div>

            <div className="space-y-2">
              <Label htmlFor="edit-plan">Plano</Label>
              <Select
                onValueChange={(value) => {
                  editForm.setValue("planId", value);
                  const plano = planos.find(p => p.id === value);
                  setSelectedPlanValue(plano?.valor || 0);
                }}
                value={editForm.watch("planId")}
              >
                <SelectTrigger>
                  <SelectValue placeholder="Selecione um plano" />
                </SelectTrigger>
                <SelectContent>
                  {planos.map((plano) => (
                    <SelectItem key={plano.id} value={plano.id}>
                      {plano.nome}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>

            <div className="space-y-2">
              <Label htmlFor="edit-planValue">Valor do Plano</Label>
              <Input
                id="edit-planValue"
                value={formatCurrency(selectedPlanValue)}
                disabled
              />
            </div>

            <div className="space-y-2">
              <Label htmlFor="edit-expiryDate">Data de Vencimento</Label>
              <Input
                id="edit-expiryDate"
                type="date"
                {...editForm.register("expiryDate")}
              />
            </div>

            <div className="space-y-2">
              <Label htmlFor="edit-status">Status</Label>
              <Select
                onValueChange={(value) =>
                  editForm.setValue("status", value as "active" | "inactive" | "suspended")
                }
                defaultValue={editForm.getValues("status")}
              >
                <SelectTrigger>
                  <SelectValue placeholder="Selecione o status" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="active">Ativo</SelectItem>
                  <SelectItem value="inactive">Inativo</SelectItem>
                  <SelectItem value="suspended">Suspenso</SelectItem>
                </SelectContent>
              </Select>
            </div>

            <DialogFooter>
              <Button
                type="button"
                variant="outline"
                onClick={() => setEditDialogOpen(false)}
                disabled={submitting}
              >
                Cancelar
              </Button>
              <Button type="submit" disabled={submitting}>
                {submitting ? "Salvando..." : "Salvar Alterações"}
              </Button>
            </DialogFooter>
          </form>
        </DialogContent>
      </Dialog>

      {/* Delete Dialog */}
      <AlertDialog open={deleteDialogOpen} onOpenChange={setDeleteDialogOpen}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Confirmar Exclusão</AlertDialogTitle>
            <AlertDialogDescription>
              Tem certeza que deseja excluir o revendedor {selectedReseller?.full_name}? 
              Esta ação não pode ser desfeita.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel disabled={submitting}>Cancelar</AlertDialogCancel>
            <AlertDialogAction
              onClick={onDelete}
              disabled={submitting}
              className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
            >
              {submitting ? "Excluindo..." : "Excluir"}
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>

      {/* Notification Dialog */}
      {selectedReseller && (
        <NotificationDialog
          open={notificationDialogOpen}
          onOpenChange={setNotificationDialogOpen}
          recipient={{
            id: selectedReseller.id,
            name: selectedReseller.full_name || "",
            phone: selectedReseller.phone,
            plan_name: selectedReseller.planos?.nome,
            plan_value: selectedReseller.planos?.valor,
            expiry_date: selectedReseller.expiry_date || undefined,
          }}
        />
      )}
    </div>
  );
}

--- Conteúdo de: src/pages/Templates.tsx ---
import { useState, useEffect } from "react";
import { Plus, Edit, Trash2, MoreVertical, MessageSquare } from "lucide-react";
import { AppHeader } from "@/components/AppHeader";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Badge } from "@/components/ui/badge";
import { useToast } from "@/hooks/use-toast";
import { supabase } from "@/integrations/supabase/client";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import * as z from "zod";

const templateSchema = z.object({
  nome: z.string().min(3, "Nome deve ter no mínimo 3 caracteres").max(100, "Nome deve ter no máximo 100 caracteres"),
  assunto: z.string().max(200, "Assunto deve ter no máximo 200 caracteres").optional(),
  corpo: z.string().min(10, "Corpo deve ter no mínimo 10 caracteres").max(2000, "Corpo deve ter no máximo 2000 caracteres"),
  tipo: z.enum(["global", "pessoal"]),
});

type TemplateFormData = z.infer<typeof templateSchema>;

interface Template {
  id: string;
  nome: string;
  assunto: string | null;
  corpo: string;
  tipo: string;
  created_at: string;
}

const placeholders = [
  { code: "{{customer_name}}", description: "Nome do cliente" },
  { code: "{{plan_name}}", description: "Nome do plano" },
  { code: "{{due_date}}", description: "Data de vencimento" },
  { code: "{{value}}", description: "Valor da cobrança" },
  { code: "{{pix_key}}", description: "Chave PIX do seu perfil" },
];

export default function Templates() {
  const [templates, setTemplates] = useState<Template[]>([]);
  const [loading, setLoading] = useState(true);
  const [dialogOpen, setDialogOpen] = useState(false);
  const [editDialogOpen, setEditDialogOpen] = useState(false);
  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);
  const [submitting, setSubmitting] = useState(false);
  const [selectedTemplate, setSelectedTemplate] = useState<Template | null>(null);
  const { toast } = useToast();

  const form = useForm<TemplateFormData>({
    resolver: zodResolver(templateSchema),
    defaultValues: {
      nome: "",
      assunto: "",
      corpo: "",
      tipo: "global",
    },
  });

  const editForm = useForm<TemplateFormData>({
    resolver: zodResolver(templateSchema),
    defaultValues: {
      nome: "",
      assunto: "",
      corpo: "",
      tipo: "global",
    },
  });

  const loadTemplates = async () => {
    try {
      setLoading(true);
      
      const { data, error } = await supabase
        .from("templates")
        .select("*")
        .order("created_at", { ascending: false });

      if (error) throw error;

      setTemplates(data || []);
    } catch (error: any) {
      console.error("Error loading templates:", error);
      toast({
        title: "Erro ao carregar templates",
        description: error.message,
        variant: "destructive",
      });
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    loadTemplates();
  }, []);

  const onSubmit = async (data: TemplateFormData) => {
    try {
      setSubmitting(true);

      const { error } = await supabase
        .from("templates")
        .insert({
          nome: data.nome,
          assunto: data.assunto || null,
          corpo: data.corpo,
          tipo: data.tipo,
        });

      if (error) throw error;

      toast({
        title: "Template criado com sucesso!",
        description: `${data.nome} foi adicionado ao sistema.`,
      });

      setDialogOpen(false);
      form.reset();
      loadTemplates();
    } catch (error: any) {
      console.error("Error creating template:", error);
      toast({
        title: "Erro ao criar template",
        description: error.message || "Ocorreu um erro ao criar o template",
        variant: "destructive",
      });
    } finally {
      setSubmitting(false);
    }
  };

  const onEdit = async (data: TemplateFormData) => {
    if (!selectedTemplate) return;

    try {
      setSubmitting(true);

      const { error } = await supabase
        .from("templates")
        .update({
          nome: data.nome,
          assunto: data.assunto || null,
          corpo: data.corpo,
          tipo: data.tipo,
        })
        .eq("id", selectedTemplate.id);

      if (error) throw error;

      toast({
        title: "Template atualizado com sucesso!",
        description: `${data.nome} foi atualizado.`,
      });

      setEditDialogOpen(false);
      editForm.reset();
      loadTemplates();
    } catch (error: any) {
      console.error("Error updating template:", error);
      toast({
        title: "Erro ao atualizar template",
        description: error.message || "Ocorreu um erro ao atualizar o template",
        variant: "destructive",
      });
    } finally {
      setSubmitting(false);
    }
  };

  const onDelete = async () => {
    if (!selectedTemplate) return;

    try {
      setSubmitting(true);

      const { error } = await supabase
        .from("templates")
        .delete()
        .eq("id", selectedTemplate.id);

      if (error) throw error;

      toast({
        title: "Template excluído com sucesso!",
        description: `${selectedTemplate.nome} foi removido do sistema.`,
      });

      setDeleteDialogOpen(false);
      setSelectedTemplate(null);
      loadTemplates();
    } catch (error: any) {
      console.error("Error deleting template:", error);
      toast({
        title: "Erro ao excluir template",
        description: error.message || "Ocorreu um erro ao excluir o template",
        variant: "destructive",
      });
    } finally {
      setSubmitting(false);
    }
  };

  const handleEdit = (template: Template) => {
    setSelectedTemplate(template);
    editForm.reset({
      nome: template.nome,
      assunto: template.assunto || "",
      corpo: template.corpo,
      tipo: template.tipo as "global" | "pessoal",
    });
    setEditDialogOpen(true);
  };

  const handleDelete = (template: Template) => {
    setSelectedTemplate(template);
    setDeleteDialogOpen(true);
  };

  return (
    <div className="min-h-screen bg-background">
      <AppHeader 
        title="Templates" 
        subtitle="Gerencie suas mensagens automáticas"
      />

      <main className="container mx-auto p-6">
        <div className="mb-6 flex justify-between items-center">
          <div>
            <h2 className="text-2xl font-bold text-foreground">Templates de Mensagem</h2>
            <p className="text-muted-foreground">
              Crie e gerencie templates para notificações automáticas
            </p>
          </div>
          <Button onClick={() => setDialogOpen(true)}>
            <Plus className="mr-2 h-4 w-4" />
            Novo Template
          </Button>
        </div>

        {loading ? (
          <div className="flex justify-center py-12">
            <div className="h-8 w-8 animate-spin rounded-full border-4 border-primary border-t-transparent"></div>
          </div>
        ) : (
          <>
            <div className="grid gap-4 mb-6">
              {templates.length === 0 ? (
                <Card>
                  <CardContent className="py-12 text-center text-muted-foreground">
                    Nenhum template encontrado. Crie seu primeiro template!
                  </CardContent>
                </Card>
              ) : (
                templates.map((template) => (
                  <Card key={template.id} className="bg-card border-border">
                    <CardHeader>
                      <div className="flex items-start justify-between">
                        <div className="flex items-center gap-2">
                          <CardTitle className="text-foreground">{template.nome}</CardTitle>
                          {template.tipo === "global" && (
                            <Badge variant="secondary">Global</Badge>
                          )}
                        </div>
                        <DropdownMenu>
                          <DropdownMenuTrigger asChild>
                            <Button variant="ghost" size="icon">
                              <MoreVertical className="h-4 w-4" />
                            </Button>
                          </DropdownMenuTrigger>
                          <DropdownMenuContent align="end">
                            <DropdownMenuItem onClick={() => handleEdit(template)}>
                              <Edit className="mr-2 h-4 w-4" />
                              Editar
                            </DropdownMenuItem>
                            <DropdownMenuItem 
                              className="text-destructive"
                              onClick={() => handleDelete(template)}
                            >
                              <Trash2 className="mr-2 h-4 w-4" />
                              Excluir
                            </DropdownMenuItem>
                          </DropdownMenuContent>
                        </DropdownMenu>
                      </div>
                    </CardHeader>
                    <CardContent>
                      {template.assunto && (
                        <p className="text-sm text-muted-foreground mb-2">
                          <strong>Assunto:</strong> {template.assunto}
                        </p>
                      )}
                      <p className="text-sm text-foreground whitespace-pre-wrap">
                        {template.corpo}
                      </p>
                    </CardContent>
                  </Card>
                ))
              )}
            </div>

            {/* Placeholders Card */}
            <Card className="bg-card border-border">
              <CardHeader>
                <CardTitle className="text-foreground">Placeholders Disponíveis</CardTitle>
                <CardDescription className="text-muted-foreground">
                  Use estes marcadores em suas mensagens para personalização automática
                </CardDescription>
              </CardHeader>
              <CardContent>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  {placeholders.map((placeholder) => (
                    <div key={placeholder.code} className="flex items-start gap-3">
                      <code className="bg-secondary text-secondary-foreground px-2 py-1 rounded text-sm font-mono">
                        {placeholder.code}
                      </code>
                      <span className="text-sm text-foreground">{placeholder.description}</span>
                    </div>
                  ))}
                </div>
              </CardContent>
            </Card>
          </>
        )}
      </main>

      {/* Create Dialog */}
      <Dialog open={dialogOpen} onOpenChange={setDialogOpen}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Novo Template</DialogTitle>
            <DialogDescription>
              Crie um novo template de mensagem
            </DialogDescription>
          </DialogHeader>

          <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
            <div className="space-y-2">
              <Label htmlFor="nome">Nome do Template</Label>
              <Input
                id="nome"
                {...form.register("nome")}
                placeholder="Ex: Lembrete de Vencimento"
              />
              {form.formState.errors.nome && (
                <p className="text-sm text-destructive">
                  {form.formState.errors.nome.message}
                </p>
              )}
            </div>

            <div className="space-y-2">
              <Label htmlFor="tipo">Tipo</Label>
              <Select
                onValueChange={(value) => form.setValue("tipo", value as "global" | "pessoal")}
                defaultValue="global"
              >
                <SelectTrigger>
                  <SelectValue placeholder="Selecione o tipo" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="global">Global</SelectItem>
                  <SelectItem value="pessoal">Pessoal</SelectItem>
                </SelectContent>
              </Select>
            </div>

            <div className="space-y-2">
              <Label htmlFor="assunto">Assunto (opcional)</Label>
              <Input
                id="assunto"
                {...form.register("assunto")}
                placeholder="Ex: Lembrete: Seu pagamento vence em breve"
              />
              {form.formState.errors.assunto && (
                <p className="text-sm text-destructive">
                  {form.formState.errors.assunto.message}
                </p>
              )}
            </div>

            <div className="space-y-2">
              <Label htmlFor="corpo">Mensagem</Label>
              <Textarea
                id="corpo"
                {...form.register("corpo")}
                placeholder="Olá {{customer_name}}, este é um lembrete de que seu plano {{plan_name}} vence em {{due_date}}..."
                rows={6}
              />
              {form.formState.errors.corpo && (
                <p className="text-sm text-destructive">
                  {form.formState.errors.corpo.message}
                </p>
              )}
            </div>

            <DialogFooter>
              <Button
                type="button"
                variant="outline"
                onClick={() => setDialogOpen(false)}
                disabled={submitting}
              >
                Cancelar
              </Button>
              <Button type="submit" disabled={submitting}>
                {submitting ? "Criando..." : "Criar Template"}
              </Button>
            </DialogFooter>
          </form>
        </DialogContent>
      </Dialog>

      {/* Edit Dialog */}
      <Dialog open={editDialogOpen} onOpenChange={setEditDialogOpen}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Editar Template</DialogTitle>
            <DialogDescription>
              Atualize as informações do template
            </DialogDescription>
          </DialogHeader>

          <form onSubmit={editForm.handleSubmit(onEdit)} className="space-y-4">
            <div className="space-y-2">
              <Label htmlFor="edit-nome">Nome do Template</Label>
              <Input
                id="edit-nome"
                {...editForm.register("nome")}
                placeholder="Ex: Lembrete de Vencimento"
              />
              {editForm.formState.errors.nome && (
                <p className="text-sm text-destructive">
                  {editForm.formState.errors.nome.message}
                </p>
              )}
            </div>

            <div className="space-y-2">
              <Label htmlFor="edit-tipo">Tipo</Label>
              <Select
                onValueChange={(value) => editForm.setValue("tipo", value as "global" | "pessoal")}
                value={editForm.watch("tipo")}
              >
                <SelectTrigger>
                  <SelectValue placeholder="Selecione o tipo" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="global">Global</SelectItem>
                  <SelectItem value="pessoal">Pessoal</SelectItem>
                </SelectContent>
              </Select>
            </div>

            <div className="space-y-2">
              <Label htmlFor="edit-assunto">Assunto (opcional)</Label>
              <Input
                id="edit-assunto"
                {...editForm.register("assunto")}
                placeholder="Ex: Lembrete: Seu pagamento vence em breve"
              />
              {editForm.formState.errors.assunto && (
                <p className="text-sm text-destructive">
                  {editForm.formState.errors.assunto.message}
                </p>
              )}
            </div>

            <div className="space-y-2">
              <Label htmlFor="edit-corpo">Mensagem</Label>
              <Textarea
                id="edit-corpo"
                {...editForm.register("corpo")}
                placeholder="Olá {{customer_name}}, este é um lembrete de que seu plano {{plan_name}} vence em {{due_date}}..."
                rows={6}
              />
              {editForm.formState.errors.corpo && (
                <p className="text-sm text-destructive">
                  {editForm.formState.errors.corpo.message}
                </p>
              )}
            </div>

            <DialogFooter>
              <Button
                type="button"
                variant="outline"
                onClick={() => setEditDialogOpen(false)}
                disabled={submitting}
              >
                Cancelar
              </Button>
              <Button type="submit" disabled={submitting}>
                {submitting ? "Salvando..." : "Salvar"}
              </Button>
            </DialogFooter>
          </form>
        </DialogContent>
      </Dialog>

      {/* Delete Dialog */}
      <AlertDialog open={deleteDialogOpen} onOpenChange={setDeleteDialogOpen}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Confirmar Exclusão</AlertDialogTitle>
            <AlertDialogDescription>
              Tem certeza que deseja excluir o template "{selectedTemplate?.nome}"?
              Esta ação não pode ser desfeita.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel disabled={submitting}>Cancelar</AlertDialogCancel>
            <AlertDialogAction
              onClick={onDelete}
              disabled={submitting}
              className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
            >
              {submitting ? "Excluindo..." : "Excluir"}
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </div>
  );
}

--- Conteúdo de: src/pages/Webhooks.tsx ---
import { useState, useEffect } from "react";
import { Save, AlertCircle } from "lucide-react";
import { AppHeader } from "@/components/AppHeader";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table";
import { Badge } from "@/components/ui/badge";
import { useToast } from "@/hooks/use-toast";
import { supabase } from "@/integrations/supabase/client";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { JsonViewDialog } from "@/components/JsonViewDialog";
interface WebhookConfig {
  config_key: string;
  webhook_url: string;
  description: string;
}

export default function Webhooks() {
  const [configs, setConfigs] = useState<Record<string, string>>({
    n8n_qr_code_generator: "",
    n8n_evolution_logout: "",
    n8n_message_sender: "",
  });
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const [evolutionHistory, setEvolutionHistory] = useState<any[]>([]);
  const [qrHistory, setQrHistory] = useState<any[]>([]);
  const [logoutHistory, setLogoutHistory] = useState<any[]>([]);
  const [messageHistory, setMessageHistory] = useState<any[]>([]);
  const { toast } = useToast();

  const loadConfigs = async () => {
    try {
      const { data, error } = await supabase
        .from("webhook_configs")
        .select("*");

      if (error) throw error;

      const configsMap: Record<string, string> = {};
      data?.forEach((config: any) => {
        configsMap[config.config_key] = config.webhook_url;
      });
      
      setConfigs((prev) => ({ ...prev, ...configsMap }));
    } catch (error: any) {
      console.error("Error loading configs:", error);
      toast({
        title: "Erro ao carregar configurações",
        description: error.message,
        variant: "destructive",
      });
    } finally {
      setLoading(false);
    }
  };

  const loadHistory = async () => {
    try {
      const [evol, qr, logout, msg] = await Promise.all([
        supabase.from("evolution_api_history").select("*").order("created_at", { ascending: false }).limit(10),
        supabase.from("n8n_qr_code_history").select("*").order("created_at", { ascending: false }).limit(10),
        supabase.from("evolution_logout_history").select("*").order("created_at", { ascending: false }).limit(10),
        supabase.from("n8n_message_sender_history").select("*").order("created_at", { ascending: false }).limit(10),
      ]);

      setEvolutionHistory(evol.data || []);
      setQrHistory(qr.data || []);
      setLogoutHistory(logout.data || []);
      setMessageHistory(msg.data || []);
    } catch (error: any) {
      console.error("Error loading history:", error);
    }
  };

  useEffect(() => {
    loadConfigs();
    loadHistory();
  }, []);

  const handleSave = async () => {
    try {
      setSaving(true);

      const updates = [
        {
          config_key: "n8n_qr_code_generator",
          webhook_url: configs.n8n_qr_code_generator,
          description: "URL do webhook n8n para gerar QR Code",
        },
        {
          config_key: "n8n_evolution_logout",
          webhook_url: configs.n8n_evolution_logout,
          description: "URL do webhook n8n para desconectar Evolution API",
        },
        {
          config_key: "n8n_message_sender",
          webhook_url: configs.n8n_message_sender,
          description: "URL do webhook n8n para enviar mensagens",
        },
      ];

      for (const update of updates) {
        const { error } = await supabase
          .from("webhook_configs")
          .upsert(update, { onConflict: "config_key" });

        if (error) throw error;
      }

      toast({
        title: "Configurações salvas!",
        description: "As URLs dos webhooks foram atualizadas com sucesso.",
      });
    } catch (error: any) {
      console.error("Error saving configs:", error);
      toast({
        title: "Erro ao salvar",
        description: error.message,
        variant: "destructive",
      });
    } finally {
      setSaving(false);
    }
  };

  const formatDate = (dateString: string) => {
    return new Date(dateString).toLocaleString("pt-BR");
  };

  if (loading) {
    return (
      <div className="min-h-screen bg-background">
        <AppHeader title="Configuração de Webhooks" subtitle="Gerencie as URLs de webhooks e monitore o histórico de eventos" />
        <div className="flex justify-center items-center h-64">
          <div className="h-8 w-8 animate-spin rounded-full border-4 border-primary border-t-transparent"></div>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-background">
      <AppHeader 
        title="Configuração de Webhooks" 
        subtitle="Gerencie as URLs de webhooks e monitore o histórico de eventos"
      />

      <main className="container mx-auto p-6">
        <Tabs defaultValue="config" className="space-y-6">
          <TabsList className="grid w-full grid-cols-4">
            <TabsTrigger value="config">Evolution API</TabsTrigger>
            <TabsTrigger value="qr">NBN QR Code</TabsTrigger>
            <TabsTrigger value="messages">NBN Mensagens</TabsTrigger>
            <TabsTrigger value="logout">Evolution Logout (NBN)</TabsTrigger>
          </TabsList>

          <TabsContent value="config">
            <Card>
              <CardHeader>
                <CardTitle>Webhook da Evolution API</CardTitle>
                <CardDescription>
                  URL pública para receber atualizações de status da Evolution API. Configure esta URL na Evolution.
                </CardDescription>
              </CardHeader>
              <CardContent className="space-y-4">
                <Alert>
                  <AlertCircle className="h-4 w-4" />
                  <AlertDescription>
                    URL do Webhook (Somente Leitura)
                  </AlertDescription>
                </Alert>
                <div className="space-y-2">
                  <Label>URL do Webhook (Somente Leitura)</Label>
                  <div className="flex gap-2">
                    <Input
                      value={`https://korfuodesmuvloncrpmn.supabase.co/functions/v1/evolution-webhook-receiver`}
                      disabled
                      className="font-mono text-sm"
                    />
                    <Button
                      variant="outline"
                      onClick={() => {
                        navigator.clipboard.writeText("https://korfuodesmuvloncrpmn.supabase.co/functions/v1/evolution-webhook-receiver");
                        toast({ title: "Copiado!", description: "URL copiada para a área de transferência" });
                      }}
                    >
                      Copiar
                    </Button>
                  </div>
                </div>

                <div className="mt-6">
                  <h3 className="text-lg font-semibold mb-4">Histórico de Requisições (Evolution → Sistema)</h3>
                  <div className="rounded-lg border">
                    <Table>
                      <TableHeader>
                        <TableRow>
                          <TableHead>Data/Hora</TableHead>
                          <TableHead>Status</TableHead>
                          <TableHead>Tipo de Evento</TableHead>
                          <TableHead>Payload</TableHead>
                        </TableRow>
                      </TableHeader>
                      <TableBody>
                        {evolutionHistory.length === 0 ? (
                          <TableRow>
                            <TableCell colSpan={4} className="text-center text-muted-foreground">
                              Nenhum evento registrado
                            </TableCell>
                          </TableRow>
                        ) : (
                          evolutionHistory.map((item) => (
                            <TableRow key={item.id}>
                              <TableCell>{formatDate(item.created_at)}</TableCell>
                              <TableCell>
                                <Badge variant="default">{item.status_code || 200}</Badge>
                              </TableCell>
                              <TableCell>{item.event_type}</TableCell>
                              <TableCell>
                                <JsonViewDialog data={item.payload} />
                              </TableCell>
                            </TableRow>
                          ))
                        )}
                      </TableBody>
                    </Table>
                  </div>
                </div>
              </CardContent>
            </Card>
          </TabsContent>

          <TabsContent value="qr">
            <Card>
              <CardHeader>
                <CardTitle>NBN QR Code</CardTitle>
                <CardDescription>
                  Configure a URL do webhook n8n para geração de QR Code
                </CardDescription>
              </CardHeader>
              <CardContent className="space-y-4">
                <div className="space-y-2">
                  <Label htmlFor="qr-url">URL do Webhook n8n</Label>
                  <Input
                    id="qr-url"
                    value={configs.n8n_qr_code_generator}
                    onChange={(e) => setConfigs({ ...configs, n8n_qr_code_generator: e.target.value })}
                    placeholder="https://seu-n8n.com/webhook/qr-code"
                  />
                </div>
                <Button onClick={handleSave} disabled={saving}>
                  <Save className="mr-2 h-4 w-4" />
                  {saving ? "Salvando..." : "Salvar"}
                </Button>

                <div className="mt-6">
                  <h3 className="text-lg font-semibold mb-4">Histórico de Requisições</h3>
                  <div className="rounded-lg border">
                    <Table>
                      <TableHeader>
                        <TableRow>
                          <TableHead>Data/Hora</TableHead>
                          <TableHead>Instância</TableHead>
                          <TableHead>Status</TableHead>
                          <TableHead>Payload</TableHead>
                        </TableRow>
                      </TableHeader>
                      <TableBody>
                        {qrHistory.length === 0 ? (
                          <TableRow>
                              <TableCell colSpan={4} className="text-center text-muted-foreground">
                                Nenhum evento registrado
                              </TableCell>
                          </TableRow>
                        ) : (
                          qrHistory.map((item) => (
                            <TableRow key={item.id}>
                              <TableCell>{formatDate(item.created_at)}</TableCell>
                              <TableCell>{item.instance_name}</TableCell>
                              <TableCell>
                                <Badge variant="default">{item.response_status || "N/A"}</Badge>
                              </TableCell>
                              <TableCell>
                                <JsonViewDialog data={item.response_data ?? item.request_payload} />
                              </TableCell>
                            </TableRow>
                          ))
                        )}
                      </TableBody>
                    </Table>
                  </div>
                </div>
              </CardContent>
            </Card>
          </TabsContent>

          <TabsContent value="messages">
            <Card>
              <CardHeader>
                <CardTitle>NBN Mensagens</CardTitle>
                <CardDescription>
                  Configure a URL do webhook n8n para envio de mensagens
                </CardDescription>
              </CardHeader>
              <CardContent className="space-y-4">
                <div className="space-y-2">
                  <Label htmlFor="msg-url">URL do Webhook n8n</Label>
                  <Input
                    id="msg-url"
                    value={configs.n8n_message_sender}
                    onChange={(e) => setConfigs({ ...configs, n8n_message_sender: e.target.value })}
                    placeholder="https://seu-n8n.com/webhook/send-message"
                  />
                </div>
                <Button onClick={handleSave} disabled={saving}>
                  <Save className="mr-2 h-4 w-4" />
                  {saving ? "Salvando..." : "Salvar"}
                </Button>

                <div className="mt-6">
                  <h3 className="text-lg font-semibold mb-4">Histórico de Mensagens Enviadas</h3>
                  <div className="rounded-lg border">
                    <Table>
                      <TableHeader>
                        <TableRow>
                          <TableHead>Data/Hora</TableHead>
                          <TableHead>Destinatário</TableHead>
                          <TableHead>Mensagem</TableHead>
                          <TableHead>Status</TableHead>
                          <TableHead>Payload</TableHead>
                        </TableRow>
                      </TableHeader>
                      <TableBody>
                        {messageHistory.length === 0 ? (
                          <TableRow>
                              <TableCell colSpan={5} className="text-center text-muted-foreground">
                                Nenhuma mensagem enviada
                              </TableCell>
                          </TableRow>
                        ) : (
                          messageHistory.map((item) => (
                            <TableRow key={item.id}>
                              <TableCell>{formatDate(item.created_at)}</TableCell>
                              <TableCell>{item.recipient_phone}</TableCell>
                              <TableCell className="max-w-xs truncate">{item.message_text}</TableCell>
                              <TableCell>
                                <Badge variant="default">{item.response_status || "N/A"}</Badge>
                              </TableCell>
                              <TableCell>
                                <JsonViewDialog data={item.request_payload} />
                              </TableCell>
                            </TableRow>
                          ))
                        )}
                      </TableBody>
                    </Table>
                  </div>
                </div>
              </CardContent>
            </Card>
          </TabsContent>

          <TabsContent value="logout">
            <Card>
              <CardHeader>
                <CardTitle>Evolution Logout (NBN)</CardTitle>
                <CardDescription>
                  Configure a URL do webhook n8n para desconexão da Evolution API
                </CardDescription>
              </CardHeader>
              <CardContent className="space-y-4">
                <div className="space-y-2">
                  <Label htmlFor="logout-url">URL do Webhook n8n</Label>
                  <Input
                    id="logout-url"
                    value={configs.n8n_evolution_logout}
                    onChange={(e) => setConfigs({ ...configs, n8n_evolution_logout: e.target.value })}
                    placeholder="https://seu-n8n.com/webhook/logout"
                  />
                </div>
                <Button onClick={handleSave} disabled={saving}>
                  <Save className="mr-2 h-4 w-4" />
                  {saving ? "Salvando..." : "Salvar"}
                </Button>

                <div className="mt-6">
                  <h3 className="text-lg font-semibold mb-4">Histórico de Desconexões</h3>
                  <div className="rounded-lg border">
                    <Table>
                      <TableHeader>
                        <TableRow>
                          <TableHead>Data/Hora</TableHead>
                          <TableHead>Instância</TableHead>
                          <TableHead>Status</TableHead>
                          <TableHead>Payload</TableHead>
                        </TableRow>
                      </TableHeader>
                      <TableBody>
                        {logoutHistory.length === 0 ? (
                          <TableRow>
                              <TableCell colSpan={4} className="text-center text-muted-foreground">
                                Nenhuma desconexão registrada
                              </TableCell>
                          </TableRow>
                        ) : (
                          logoutHistory.map((item) => (
                            <TableRow key={item.id}>
                              <TableCell>{formatDate(item.created_at)}</TableCell>
                              <TableCell>{item.instance_name}</TableCell>
                              <TableCell>
                                <Badge variant="default">{item.response_status || "N/A"}</Badge>
                              </TableCell>
                              <TableCell>
                                <JsonViewDialog data={item.request_payload} />
                              </TableCell>
                            </TableRow>
                          ))
                        )}
                      </TableBody>
                    </Table>
                  </div>
                </div>
              </CardContent>
            </Card>
          </TabsContent>
        </Tabs>
      </main>
    </div>
  );
}

--- Conteúdo de: src/pages/WhatsAppConnection.tsx ---
import { useState, useEffect } from "react";
import { QrCode, X, Power, Loader2 } from "lucide-react";
import { AppHeader } from "@/components/AppHeader";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { useToast } from "@/hooks/use-toast";
import { supabase } from "@/integrations/supabase/client";

export default function WhatsAppConnection() {
  const [connectionStatus, setConnectionStatus] = useState<string>("disconnected");
  const [qrCodeBase64, setQrCodeBase64] = useState<string | null>(null);
  const [instanceName, setInstanceName] = useState<string>("");
  const [loading, setLoading] = useState(true);
  const [processing, setProcessing] = useState(false);
  const { toast } = useToast();

  const loadUserInstance = async () => {
    try {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) throw new Error("Não autenticado");

      const { data, error } = await supabase
        .from("user_instances")
        .select("*")
        .eq("user_id", user.id)
        .maybeSingle();

      if (error && error.code !== 'PGRST116') throw error;

      if (data) {
        setConnectionStatus(data.connection_status);
        setQrCodeBase64(data.qr_code_base64);
        setInstanceName(data.instance_name);
      } else {
        // Criar instância com nome baseado no email
        const newInstanceName = `instance_${user.email?.split('@')[0]}_${Date.now()}`;
        setInstanceName(newInstanceName);
      }
    } catch (error: any) {
      console.error("Error loading instance:", error);
      toast({
        title: "Erro ao carregar conexão",
        description: error.message,
        variant: "destructive",
      });
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    loadUserInstance();

    // Configurar Realtime
    const channel = supabase
      .channel('user-instance-changes')
      .on(
        'postgres_changes',
        {
          event: 'UPDATE',
          schema: 'public',
          table: 'user_instances'
        },
        (payload) => {
          console.log('Realtime update received:', payload);
          if (payload.new && typeof payload.new === 'object') {
            const newData = payload.new as any;
            
            // Atualizar estados locais
            if ('connection_status' in newData) {
              console.log('Updating connection_status to:', newData.connection_status);
              setConnectionStatus(newData.connection_status);
            }
            if ('qr_code_base64' in newData) {
              console.log('Updating qr_code_base64');
              setQrCodeBase64(newData.qr_code_base64);
            }

            // Mostrar toast quando conectar
            if (newData.connection_status === 'connected') {
              toast({
                title: "WhatsApp Conectado!",
                description: "Sua conta foi conectada com sucesso",
              });
            }
          }
        }
      )
      .subscribe((status) => {
        console.log('Realtime subscription status:', status);
      });

    return () => {
      console.log('Removing Realtime channel');
      supabase.removeChannel(channel);
    };
  }, [toast]);

  const handleGenerateQR = async () => {
    try {
      setProcessing(true);

      const { data: { user } } = await supabase.auth.getUser();
      if (!user) throw new Error("Não autenticado");

      // Criar ou atualizar instância
      const { error: upsertError } = await supabase
        .from("user_instances")
        .upsert({
          user_id: user.id,
          instance_name: instanceName,
          connection_status: "connecting",
          qr_code_base64: null,
        }, {
          onConflict: "user_id"
        });

      if (upsertError) throw upsertError;

      setConnectionStatus("connecting");

      // Buscar URL do webhook n8n
      const { data: configData } = await supabase
        .from("webhook_configs")
        .select("webhook_url")
        .eq("config_key", "n8n_qr_code_generator")
        .maybeSingle();

      if (!configData?.webhook_url) {
        throw new Error("URL do webhook n8n não configurada. Configure em /settings/webhooks");
      }

      // Chamar n8n
      const webhookUrl = `https://korfuodesmuvloncrpmn.supabase.co/functions/v1/evolution-webhook-receiver`;
      
      const response = await fetch(configData.webhook_url, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          instanceName: instanceName,
          webhook: {
            url: webhookUrl,
            events: ["CONNECTION_UPDATE"]
          }
        }),
      });

      const responseData = await response.json();

      // Logar interação
      await supabase.functions.invoke("log-n8n-qr-interaction", {
        body: {
          instanceName,
          requestPayload: {
            instanceName,
            webhook: { url: webhookUrl, events: ["CONNECTION_UPDATE"] },
          },
          responseStatus: response.status,
          responseData,
        },
      });

      // Normalizar resposta (array ou objeto) e extrair base64
      let qrBase64: string | undefined;
      if (Array.isArray(responseData)) {
        qrBase64 = responseData[0]?.base64;
      } else if (responseData && typeof responseData === "object") {
        qrBase64 = (responseData as any).base64;
      }

      if (response.ok && qrBase64) {
        // Remover prefixo data URL se presente
        const base64Only = qrBase64.includes("base64,")
          ? qrBase64.split("base64,")[1]
          : qrBase64;

        // Atualizar QR Code
        await supabase
          .from("user_instances")
          .update({ qr_code_base64: base64Only })
          .eq("instance_name", instanceName);

        setQrCodeBase64(base64Only);

        toast({
          title: "QR Code gerado!",
          description: "Escaneie o código com seu WhatsApp",
        });
      } else {
        throw new Error("Resposta do n8n não contém QR Code");
      }
    } catch (error: any) {
      console.error("Error generating QR:", error);
      toast({
        title: "Erro ao gerar QR Code",
        description: error.message,
        variant: "destructive",
      });
      
      // Resetar status
      await supabase
        .from("user_instances")
        .update({ connection_status: "disconnected" })
        .eq("instance_name", instanceName);
      
      setConnectionStatus("disconnected");
    } finally {
      setProcessing(false);
    }
  };

  const handleDisconnect = async () => {
    try {
      setProcessing(true);

      // Buscar URL do webhook de logout
      const { data: configData } = await supabase
        .from("webhook_configs")
        .select("webhook_url")
        .eq("config_key", "n8n_evolution_logout")
        .maybeSingle();

      if (!configData?.webhook_url) {
        throw new Error("URL do webhook de logout não configurada");
      }

      // Chamar n8n para logout
      const response = await fetch(configData.webhook_url, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          instanceName: instanceName,
        }),
      });

      const { data: { user } } = await supabase.auth.getUser();
      if (user) {
        // Logar tentativa de desconexão
        await supabase
          .from("evolution_logout_history")
          .insert({
            user_id: user.id,
            instance_name: instanceName,
            request_payload: { instanceName },
            response_status: response.status,
          });
      }

      toast({
        title: "Desconectando...",
        description: "Aguarde enquanto desconectamos sua instância",
      });
    } catch (error: any) {
      console.error("Error disconnecting:", error);
      toast({
        title: "Erro ao desconectar",
        description: error.message,
        variant: "destructive",
      });
    } finally {
      setProcessing(false);
    }
  };

  const getStatusBadge = () => {
    switch (connectionStatus) {
      case "connected":
        return <Badge variant="default">Conectado</Badge>;
      case "connecting":
        return <Badge variant="secondary">Conectando...</Badge>;
      default:
        return <Badge variant="destructive">Desconectado</Badge>;
    }
  };

  if (loading) {
    return (
      <div className="min-h-screen bg-background">
        <AppHeader title="Conexão com WhatsApp" subtitle="Gerencie a integração do seu sistema com o WhatsApp" />
        <div className="flex justify-center items-center h-64">
          <Loader2 className="h-8 w-8 animate-spin text-primary" />
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-background">
      <AppHeader 
        title="Conexão com WhatsApp" 
        subtitle="Gerencie a integração do seu sistema com o WhatsApp"
      />

      <main className="container mx-auto p-6 max-w-2xl">
        <Card>
          <CardHeader>
            <div className="flex items-center justify-between">
              <div>
                <CardTitle>Conexão com WhatsApp</CardTitle>
                <CardDescription>
                  Para enviar notificações, conecte seu número de WhatsApp.
                </CardDescription>
              </div>
              {getStatusBadge()}
            </div>
          </CardHeader>
          <CardContent className="space-y-6">
            {connectionStatus === "disconnected" && (
              <div className="space-y-4">
                <p className="text-sm text-muted-foreground">
                  Para enviar notificações, conecte seu número de WhatsApp.
                </p>
                <Button 
                  onClick={handleGenerateQR} 
                  disabled={processing}
                  className="w-full"
                >
                  {processing ? (
                    <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                  ) : (
                    <QrCode className="mr-2 h-4 w-4" />
                  )}
                  Gerar QR Code
                </Button>
              </div>
            )}

            {connectionStatus === "connecting" && qrCodeBase64 && (
              <div className="space-y-4">
                <div className="flex justify-center bg-white p-4 rounded-lg">
                  <img 
                    src={`data:image/png;base64,${qrCodeBase64}`}
                    alt="QR Code WhatsApp"
                    className="w-80 h-80"
                  />
                </div>
                <p className="text-sm text-center text-muted-foreground">
                  Abra o WhatsApp no seu celular e escaneie este código
                </p>
                <Button 
                  onClick={() => {
                    setConnectionStatus("disconnected");
                    setQrCodeBase64(null);
                  }}
                  variant="outline"
                  className="w-full"
                >
                  <X className="mr-2 h-4 w-4" />
                  Cancelar
                </Button>
              </div>
            )}

            {connectionStatus === "connected" && (
              <div className="space-y-4">
                <p className="text-sm text-muted-foreground">
                  Seu WhatsApp está conectado e pronto para enviar notificações.
                </p>
                <Button 
                  onClick={handleDisconnect} 
                  disabled={processing}
                  variant="destructive"
                  className="w-full"
                >
                  {processing ? (
                    <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                  ) : (
                    <Power className="mr-2 h-4 w-4" />
                  )}
                  Desconectar
                </Button>
              </div>
            )}
          </CardContent>
        </Card>
      </main>
    </div>
  );
}

--- Conteúdo de: src/hooks/use-toast.ts ---
import * as React from "react";

import type { ToastActionElement, ToastProps } from "@/components/ui/toast";

const TOAST_LIMIT = 1;
const TOAST_REMOVE_DELAY = 1000000;

type ToasterToast = ToastProps & {
  id: string;
  title?: React.ReactNode;
  description?: React.ReactNode;
  action?: ToastActionElement;
};

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const;

let count = 0;

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER;
  return count.toString();
}

type ActionType = typeof actionTypes;

type Action =
  | {
      type: ActionType["ADD_TOAST"];
      toast: ToasterToast;
    }
  | {
      type: ActionType["UPDATE_TOAST"];
      toast: Partial<ToasterToast>;
    }
  | {
      type: ActionType["DISMISS_TOAST"];
      toastId?: ToasterToast["id"];
    }
  | {
      type: ActionType["REMOVE_TOAST"];
      toastId?: ToasterToast["id"];
    };

interface State {
  toasts: ToasterToast[];
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>();

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return;
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId);
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    });
  }, TOAST_REMOVE_DELAY);

  toastTimeouts.set(toastId, timeout);
};

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      };

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) => (t.id === action.toast.id ? { ...t, ...action.toast } : t)),
      };

    case "DISMISS_TOAST": {
      const { toastId } = action;

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId);
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id);
        });
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t,
        ),
      };
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        };
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      };
  }
};

const listeners: Array<(state: State) => void> = [];

let memoryState: State = { toasts: [] };

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action);
  listeners.forEach((listener) => {
    listener(memoryState);
  });
}

type Toast = Omit<ToasterToast, "id">;

function toast({ ...props }: Toast) {
  const id = genId();

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    });
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id });

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss();
      },
    },
  });

  return {
    id: id,
    dismiss,
    update,
  };
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState);

  React.useEffect(() => {
    listeners.push(setState);
    return () => {
      const index = listeners.indexOf(setState);
      if (index > -1) {
        listeners.splice(index, 1);
      }
    };
  }, [state]);

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  };
}

export { useToast, toast };
======================================
  7. SCHEMA COMPLETO COM POLÍTICAS DE SEGURANÇA (RLS)
======================================



SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;


COMMENT ON SCHEMA "public" IS 'standard public schema';



CREATE EXTENSION IF NOT EXISTS "pg_graphql" WITH SCHEMA "graphql";






CREATE EXTENSION IF NOT EXISTS "pg_stat_statements" WITH SCHEMA "extensions";






CREATE EXTENSION IF NOT EXISTS "pgcrypto" WITH SCHEMA "extensions";






CREATE EXTENSION IF NOT EXISTS "supabase_vault" WITH SCHEMA "vault";






CREATE EXTENSION IF NOT EXISTS "uuid-ossp" WITH SCHEMA "extensions";






CREATE TYPE "public"."app_role" AS ENUM (
    'master',
    'reseller'
);


ALTER TYPE "public"."app_role" OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."handle_new_user"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
BEGIN
  INSERT INTO public.profiles (user_id, full_name)
  VALUES (
    new.id,
    COALESCE(new.raw_user_meta_data->>'full_name', '')
  );
  RETURN new;
END;
$$;


ALTER FUNCTION "public"."handle_new_user"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."has_role"("_user_id" "uuid", "_role" "public"."app_role") RETURNS boolean
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  SELECT EXISTS (
    SELECT 1
    FROM public.user_roles
    WHERE user_id = _user_id
      AND role = _role
  );
$$;


ALTER FUNCTION "public"."has_role"("_user_id" "uuid", "_role" "public"."app_role") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_updated_at_column"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public'
    AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_updated_at_column"() OWNER TO "postgres";

SET default_tablespace = '';

SET default_table_access_method = "heap";


CREATE TABLE IF NOT EXISTS "public"."evolution_api_history" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "instance_name" "text" NOT NULL,
    "event_type" "text" NOT NULL,
    "status_code" integer,
    "payload" "jsonb",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."evolution_api_history" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."evolution_logout_history" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "instance_name" "text" NOT NULL,
    "request_payload" "jsonb",
    "response_status" integer,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."evolution_logout_history" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."n8n_message_sender_history" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "instance_name" "text" NOT NULL,
    "recipient_phone" "text" NOT NULL,
    "message_text" "text" NOT NULL,
    "request_payload" "jsonb",
    "response_status" integer,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."n8n_message_sender_history" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."n8n_qr_code_history" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "instance_name" "text" NOT NULL,
    "request_payload" "jsonb",
    "response_status" integer,
    "response_data" "jsonb",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."n8n_qr_code_history" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."planos" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "nome" "text" NOT NULL,
    "valor" numeric DEFAULT 0 NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."planos" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."profiles" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "full_name" "text",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "created_by" "uuid",
    "email" "text",
    "plan_id" "uuid",
    "expiry_date" timestamp with time zone,
    "status" "text" DEFAULT 'active'::"text",
    "cpf" "text" DEFAULT ''::"text" NOT NULL,
    "pix_key" "text",
    "phone" "text" DEFAULT ''::"text" NOT NULL
);


ALTER TABLE "public"."profiles" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."templates" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "nome" "text" NOT NULL,
    "assunto" "text",
    "corpo" "text" NOT NULL,
    "tipo" "text" DEFAULT 'global'::"text" NOT NULL,
    "user_id" "uuid" DEFAULT "auth"."uid"() NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."templates" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."user_instances" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "instance_name" "text" NOT NULL,
    "connection_status" "text" DEFAULT 'disconnected'::"text" NOT NULL,
    "qr_code_base64" "text",
    "last_connected_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE ONLY "public"."user_instances" REPLICA IDENTITY FULL;


ALTER TABLE "public"."user_instances" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."user_roles" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "role" "public"."app_role" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."user_roles" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."webhook_configs" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "config_key" "text" NOT NULL,
    "webhook_url" "text" NOT NULL,
    "description" "text",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."webhook_configs" OWNER TO "postgres";


ALTER TABLE ONLY "public"."evolution_api_history"
    ADD CONSTRAINT "evolution_api_history_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."evolution_logout_history"
    ADD CONSTRAINT "evolution_logout_history_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."n8n_message_sender_history"
    ADD CONSTRAINT "n8n_message_sender_history_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."n8n_qr_code_history"
    ADD CONSTRAINT "n8n_qr_code_history_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."planos"
    ADD CONSTRAINT "planos_nome_key" UNIQUE ("nome");



ALTER TABLE ONLY "public"."planos"
    ADD CONSTRAINT "planos_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."profiles"
    ADD CONSTRAINT "profiles_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."profiles"
    ADD CONSTRAINT "profiles_user_id_key" UNIQUE ("user_id");



ALTER TABLE ONLY "public"."templates"
    ADD CONSTRAINT "templates_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."user_instances"
    ADD CONSTRAINT "user_instances_instance_name_key" UNIQUE ("instance_name");



ALTER TABLE ONLY "public"."user_instances"
    ADD CONSTRAINT "user_instances_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."user_instances"
    ADD CONSTRAINT "user_instances_user_id_key" UNIQUE ("user_id");



ALTER TABLE ONLY "public"."user_roles"
    ADD CONSTRAINT "user_roles_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."user_roles"
    ADD CONSTRAINT "user_roles_user_id_role_key" UNIQUE ("user_id", "role");



ALTER TABLE ONLY "public"."webhook_configs"
    ADD CONSTRAINT "webhook_configs_config_key_key" UNIQUE ("config_key");



ALTER TABLE ONLY "public"."webhook_configs"
    ADD CONSTRAINT "webhook_configs_pkey" PRIMARY KEY ("id");



CREATE INDEX "idx_profiles_email" ON "public"."profiles" USING "btree" ("email");



CREATE INDEX "idx_profiles_status" ON "public"."profiles" USING "btree" ("status");



CREATE OR REPLACE TRIGGER "update_planos_updated_at" BEFORE UPDATE ON "public"."planos" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_profiles_updated_at" BEFORE UPDATE ON "public"."profiles" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_templates_updated_at" BEFORE UPDATE ON "public"."templates" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_user_instances_updated_at" BEFORE UPDATE ON "public"."user_instances" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_user_roles_updated_at" BEFORE UPDATE ON "public"."user_roles" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_webhook_configs_updated_at" BEFORE UPDATE ON "public"."webhook_configs" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



ALTER TABLE ONLY "public"."evolution_logout_history"
    ADD CONSTRAINT "evolution_logout_history_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."profiles"
    ADD CONSTRAINT "fk_profiles_plan_id" FOREIGN KEY ("plan_id") REFERENCES "public"."planos"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."n8n_message_sender_history"
    ADD CONSTRAINT "n8n_message_sender_history_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."n8n_qr_code_history"
    ADD CONSTRAINT "n8n_qr_code_history_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."profiles"
    ADD CONSTRAINT "profiles_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."profiles"
    ADD CONSTRAINT "profiles_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."user_instances"
    ADD CONSTRAINT "user_instances_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."user_roles"
    ADD CONSTRAINT "user_roles_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



CREATE POLICY "Masters can view profiles they created" ON "public"."profiles" FOR SELECT USING (("public"."has_role"("auth"."uid"(), 'master'::"public"."app_role") AND ("auth"."uid"() = "created_by")));



CREATE POLICY "Masters can view roles" ON "public"."user_roles" FOR SELECT USING ("public"."has_role"("auth"."uid"(), 'master'::"public"."app_role"));



CREATE POLICY "Masters podem atualizar planos" ON "public"."planos" FOR UPDATE TO "authenticated" USING ("public"."has_role"("auth"."uid"(), 'master'::"public"."app_role"));



CREATE POLICY "Masters podem atualizar templates" ON "public"."templates" FOR UPDATE TO "authenticated" USING ("public"."has_role"("auth"."uid"(), 'master'::"public"."app_role"));



CREATE POLICY "Masters podem atualizar webhook configs" ON "public"."webhook_configs" FOR UPDATE TO "authenticated" USING ("public"."has_role"("auth"."uid"(), 'master'::"public"."app_role"));



CREATE POLICY "Masters podem deletar planos" ON "public"."planos" FOR DELETE TO "authenticated" USING ("public"."has_role"("auth"."uid"(), 'master'::"public"."app_role"));



CREATE POLICY "Masters podem deletar templates" ON "public"."templates" FOR DELETE TO "authenticated" USING ("public"."has_role"("auth"."uid"(), 'master'::"public"."app_role"));



CREATE POLICY "Masters podem deletar webhook configs" ON "public"."webhook_configs" FOR DELETE TO "authenticated" USING ("public"."has_role"("auth"."uid"(), 'master'::"public"."app_role"));



CREATE POLICY "Masters podem inserir planos" ON "public"."planos" FOR INSERT TO "authenticated" WITH CHECK ("public"."has_role"("auth"."uid"(), 'master'::"public"."app_role"));



CREATE POLICY "Masters podem inserir templates" ON "public"."templates" FOR INSERT TO "authenticated" WITH CHECK ("public"."has_role"("auth"."uid"(), 'master'::"public"."app_role"));



CREATE POLICY "Masters podem inserir webhook configs" ON "public"."webhook_configs" FOR INSERT TO "authenticated" WITH CHECK ("public"."has_role"("auth"."uid"(), 'master'::"public"."app_role"));



CREATE POLICY "Masters podem ver histórico da Evolution API" ON "public"."evolution_api_history" FOR SELECT TO "authenticated" USING ("public"."has_role"("auth"."uid"(), 'master'::"public"."app_role"));



CREATE POLICY "Masters podem ver todas as instâncias" ON "public"."user_instances" FOR SELECT TO "authenticated" USING ("public"."has_role"("auth"."uid"(), 'master'::"public"."app_role"));



CREATE POLICY "Masters podem ver todo histórico QR" ON "public"."n8n_qr_code_history" FOR SELECT TO "authenticated" USING ("public"."has_role"("auth"."uid"(), 'master'::"public"."app_role"));



CREATE POLICY "Masters podem ver todo histórico de mensagens" ON "public"."n8n_message_sender_history" FOR SELECT TO "authenticated" USING ("public"."has_role"("auth"."uid"(), 'master'::"public"."app_role"));



CREATE POLICY "Masters podem ver todo histórico logout" ON "public"."evolution_logout_history" FOR SELECT TO "authenticated" USING ("public"."has_role"("auth"."uid"(), 'master'::"public"."app_role"));



CREATE POLICY "Masters podem visualizar webhook configs" ON "public"."webhook_configs" FOR SELECT TO "authenticated" USING ("public"."has_role"("auth"."uid"(), 'master'::"public"."app_role"));



CREATE POLICY "Service role pode inserir histórico Evolution API" ON "public"."evolution_api_history" FOR INSERT TO "service_role" WITH CHECK (true);



CREATE POLICY "Users can insert their own profile" ON "public"."profiles" FOR INSERT WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can update their own profile" ON "public"."profiles" FOR UPDATE USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can view their own profile" ON "public"."profiles" FOR SELECT USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can view their own roles" ON "public"."user_roles" FOR SELECT USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Usuários autenticados podem visualizar planos" ON "public"."planos" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "Usuários autenticados podem visualizar templates" ON "public"."templates" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "Usuários podem atualizar sua própria instância" ON "public"."user_instances" FOR UPDATE TO "authenticated" USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Usuários podem inserir seu próprio histórico QR" ON "public"."n8n_qr_code_history" FOR INSERT TO "authenticated" WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "Usuários podem inserir seu próprio histórico de mensagens" ON "public"."n8n_message_sender_history" FOR INSERT TO "authenticated" WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "Usuários podem inserir seu próprio histórico logout" ON "public"."evolution_logout_history" FOR INSERT TO "authenticated" WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "Usuários podem inserir sua própria instância" ON "public"."user_instances" FOR INSERT TO "authenticated" WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "Usuários podem ver seu próprio histórico QR" ON "public"."n8n_qr_code_history" FOR SELECT TO "authenticated" USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Usuários podem ver seu próprio histórico de mensagens" ON "public"."n8n_message_sender_history" FOR SELECT TO "authenticated" USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Usuários podem ver seu próprio histórico logout" ON "public"."evolution_logout_history" FOR SELECT TO "authenticated" USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Usuários podem ver sua própria instância" ON "public"."user_instances" FOR SELECT TO "authenticated" USING (("auth"."uid"() = "user_id"));



ALTER TABLE "public"."evolution_api_history" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."evolution_logout_history" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."n8n_message_sender_history" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."n8n_qr_code_history" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."planos" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."profiles" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."templates" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."user_instances" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."user_roles" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."webhook_configs" ENABLE ROW LEVEL SECURITY;




ALTER PUBLICATION "supabase_realtime" OWNER TO "postgres";






ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."user_instances";



GRANT USAGE ON SCHEMA "public" TO "postgres";
GRANT USAGE ON SCHEMA "public" TO "anon";
GRANT USAGE ON SCHEMA "public" TO "authenticated";
GRANT USAGE ON SCHEMA "public" TO "service_role";



GRANT ALL ON TYPE "public"."app_role" TO "authenticated";

























































































































































GRANT ALL ON FUNCTION "public"."handle_new_user"() TO "anon";
GRANT ALL ON FUNCTION "public"."handle_new_user"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."handle_new_user"() TO "service_role";



GRANT ALL ON FUNCTION "public"."has_role"("_user_id" "uuid", "_role" "public"."app_role") TO "anon";
GRANT ALL ON FUNCTION "public"."has_role"("_user_id" "uuid", "_role" "public"."app_role") TO "authenticated";
GRANT ALL ON FUNCTION "public"."has_role"("_user_id" "uuid", "_role" "public"."app_role") TO "service_role";



GRANT ALL ON FUNCTION "public"."update_updated_at_column"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_updated_at_column"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_updated_at_column"() TO "service_role";


















GRANT ALL ON TABLE "public"."evolution_api_history" TO "anon";
GRANT ALL ON TABLE "public"."evolution_api_history" TO "authenticated";
GRANT ALL ON TABLE "public"."evolution_api_history" TO "service_role";



GRANT ALL ON TABLE "public"."evolution_logout_history" TO "anon";
GRANT ALL ON TABLE "public"."evolution_logout_history" TO "authenticated";
GRANT ALL ON TABLE "public"."evolution_logout_history" TO "service_role";



GRANT ALL ON TABLE "public"."n8n_message_sender_history" TO "anon";
GRANT ALL ON TABLE "public"."n8n_message_sender_history" TO "authenticated";
GRANT ALL ON TABLE "public"."n8n_message_sender_history" TO "service_role";



GRANT ALL ON TABLE "public"."n8n_qr_code_history" TO "anon";
GRANT ALL ON TABLE "public"."n8n_qr_code_history" TO "authenticated";
GRANT ALL ON TABLE "public"."n8n_qr_code_history" TO "service_role";



GRANT ALL ON TABLE "public"."planos" TO "anon";
GRANT ALL ON TABLE "public"."planos" TO "authenticated";
GRANT ALL ON TABLE "public"."planos" TO "service_role";



GRANT ALL ON TABLE "public"."profiles" TO "anon";
GRANT ALL ON TABLE "public"."profiles" TO "authenticated";
GRANT ALL ON TABLE "public"."profiles" TO "service_role";



GRANT ALL ON TABLE "public"."templates" TO "anon";
GRANT ALL ON TABLE "public"."templates" TO "authenticated";
GRANT ALL ON TABLE "public"."templates" TO "service_role";



GRANT ALL ON TABLE "public"."user_instances" TO "anon";
GRANT ALL ON TABLE "public"."user_instances" TO "authenticated";
GRANT ALL ON TABLE "public"."user_instances" TO "service_role";



GRANT ALL ON TABLE "public"."user_roles" TO "anon";
GRANT ALL ON TABLE "public"."user_roles" TO "authenticated";
GRANT ALL ON TABLE "public"."user_roles" TO "service_role";



GRANT ALL ON TABLE "public"."webhook_configs" TO "anon";
GRANT ALL ON TABLE "public"."webhook_configs" TO "authenticated";
GRANT ALL ON TABLE "public"."webhook_configs" TO "service_role";









ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "service_role";






ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "service_role";






ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "service_role";































RESET ALL;

